## 第1章 C++初识

### 1.1 第一个C++程序

* 创建项目
* 创建文件
* 编写代码
* 运行程序

### 1.2 注释

作用：添加说明
两种格式：

    1. 单行注释  //描述信息
    2. 多行注释  /* */

给类加注释

```c++
/**
*@brief
*
*/
```



### 1.3 变量

作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

- 变量定义（define）

- 变量的声明（declaration）

- 名字的作用域

### 1.4 常量

作用：用于记录程序中不可更改的数据
C++定义常量的两种方式：

1. #define 宏常量  ```#define 常量名 常量值```
   * 通常定义在文件上方，表示一个常量
2. const修饰的变量 ```const 数据类型 常量名 = 常量值```
   * 通常在变量定义前加关键字const，修饰变量为常量，不可修改

### 1.5 关键字

或 标识符
作用：关键字是C++中预先保留的单词（标识符

C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`



### 1.6 标识符命名规则

作用：规则

* 标识符不能是关键字
* 标识符只能由字母，数字，下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写


### 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** ``cin >> 变量 ``

示例：

```c++
int main(){
	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << a << endl;
	//浮点型输入
	double d = 0;
	cout << "请输入浮点型变量：" << endl;
	cin >> d;
	cout << d << endl;
	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << ch << endl;
	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << str << endl;
	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量：" << endl;
	cin >> flag;
	cout << flag << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```

## 第2章 变量和基本（数据）类型

C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存
数据类型存在的意义：给变量分配合适的内存空间。避免浪费内存

### 2.1 基本内置类型

基本内置类型包含算术类型（arithmetic type）和空类型（void）

#### 1 算术类型

>  算术类型分为两类：整型（包括字符和布尔）和浮点型



##### 整型

作用：整数类型的数据
C++能表示整型的类型有以下几种，区别在于所占的内存空间不同：
一个字节为8位

| 数据类型          | 占用空间                                    | 取值范围                        |
| ----------------- | ------------------------------------------- | ------------------------------- |
| short短整型       | 2字节                                       | (-2^15~2^15-1)（-32768～32767） |
| int整型           | 4字节                                       | (-2^31~2^31-1)                  |
| long长整型        | win4字节，Linux4字节（32位），8字节（64位） | (-2^31~2^31-1)                  |
| long long长长整型 | 8字节                                       | (-2^63~2^63-1)                  |


#####  sizeof关键字

作用：可以统计数据类型所占用的内存大小
语法：```sizeof(数据类型/变量)```
short<int<=long<=long long

```
int main() {
	cout << "short 类型所占内存空间为： " << sizeof(short) << endl;
	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;
	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;
	cout << "long long 类型所占内存空间为： " << sizeof(long long) << endl;
	system("pause");
	return 0;
}
```


#####  实型（浮点型）

作用：表示小数
浮点型分为两种：

1. 单精度float
2. 双精度double
3. 默认情况下输出小数，只输出6位

两者的区别在于表示的有效数字范围不同

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15-16位有效数字 |

小数点前也算有效数字

```
float f1=3.14f //默认为double

//科学计数法
float f=3e2  //3* 10^2
float f=3e-2 //3* 0.1^2
```

#####  字符型 

作用：字符型变量用于显示单个字符
语法： ```char ch='a'```

```
注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串
```

* C和C++中字符型变量只占用1字节（一个char的大小应该和一个机器字节一样）
* 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII码放入存储单元

示例：

```C++
int main() {
	
	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;
	//ch = "abcde"; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符
	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;
	system("pause");
	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |



ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。



LF：换行

CR：回车

CR：Carriage Return，对应ASCII中转义字符\r，表示回车

LF：Linefeed，对应ASCII中转义字符\n，表示换行

CRLF：Carriage Return & Linefeed，\r\n，表示回车并换行

在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。

当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。



##### 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```
int main() {
	
	
	cout << "\\" << endl;
	cout << "\tHello" << endl;
	cout << "\n" << endl;
	system("pause");
	return 0;
}
```



#####  字符串型

**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   	char str1[] = "hello world";
   	cout << str1 << endl;
       
   	system("pause");
   	return 0;
   }
   ```

> 注意：C风格的字符串要用双引号括起来


2. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   int main() {
   	string str = "hello world";
   	cout << str << endl;
   	
   	system("pause");
   	return 0;
   }
   ```

> 注意：C++风格字符串，需要加入头文件==#include\<string>==




#####  布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```c++
int main() {
	bool flag = true;
	cout << flag << endl; // 1
	flag = false;
	cout << flag << endl; // 0
	cout << "size of bool = " << sizeof(bool) << endl; //1
	
	system("pause");
	return 0;
}
```






#### 2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种被大多数类型支持，就是将对象从一种给定的类型***转换（convert）***为另一种相关类型

- 非布尔型的算术值赋给布尔型，初始值为0则结果为false，否则为true；布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。布尔与非布尔类型的算术值 （int float char）
- 将浮点数赋给整型，仅保留小数点之前的部分
- 整型赋给浮点型，小数部分记为0
- 赋给无符号类型一个超出它表示范围的值，结果是初始值对无符号类型表示数值总数取模后的余数。
- 赋给带符号类型一个超出它表示范围的值，结果是未定义的（undefined）

- 含有无符号类型的表达式
  - 当一个算术表达式中既有无符号数又有int时，int会转换成无符号数
    - 负数转换成无符号数：结果等于这个负数加上无符号数的模 
  - 不要混用带符号数与无符号数

例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

```
有整数a和b，a对b进行取模或取余运算
1、求整数商：c=a/b
取模运算在计算商值向负无穷方向舍弃小数位
取余运算在计算商值向0方向舍弃小数位
2、计算模或者余数：r=a-(c*b)
注：取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。

mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的

当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。

具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致。
```

在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.

```
计算机中带符号的整数采用二进制的补码进行存储
正数的补码等于其二进制编码
负数的补码等于其绝对值的二进制编码，取反，再加1
在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111
unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。
```


#### 3 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。

- 每个字面值常量都对应着一种数据类型。字面值常量的形式和值决定了它的数据类型。

  - 整型和浮点型字面值。

    - 20 **十进制**
    - 024 **八进制**
    - 0x14 **十六进制**

  - 字符和字符串字面值。

    - 使用空格连接，继承自C。

    - 字符字面值：单引号， `'a'`

    - 字符串字面值：双引号， `"Hello World"`

    - 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则他们实际上是一个整体。

      - 分多行书写字符串。

      ```
      std:cout<<"wow, a really, really long string"
                "literal that spans two lines" <<std::endl;
      ```

  - 转义序列。`\n`、`\t`等。

  - 指定字面值的类型

    - 字符和字符串字面值
      - u : char16_t
      - U : char32_t
      - L : wchar_t
      - u8 : char 
    - 整型字面值
      - u or U : unsigned
      - l or L : long
      - ll or LL : long long
    - 浮点型字面值
      - f or F : float
      - l or L : long double 

  - 布尔字面值。`true`，`false`。

  - 指针字面值。`nullptr`

> 字符串型实际上时常量字符构成的数组，结尾处以`'\0'`结束，所以字符串类型实际上长度比内容多1。

### 2.2 变量

**variable**

作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

地址编号
0x0000       10
a

####  变量定义（define）

  * **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
  * 初始化（initialize）：当对象创建时获得了一个特定的值，我们说这个对象被初始化了
    * 如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化
    * 如果不使用等号，则执行的是直接初始化
    * 如果初始值只有一个，直接初始化与拷贝初始化都可以。如果初始值有多个，一般来说只能使用直接初始化
    * string s1 = "hello"; //拷贝初始化
    * string s2("bye"); //直接初始化

> 初始化与赋值是两个完全不同的操作。初始化的含义是创建变量的同时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来代替

初始化的几种形式

```
  int i=0; //拷贝初始化
  int i={0}; //初始化列表
  int i{0}; //初始化列表
  int i(0); //直接初始化
```

> 一般来说，这几种初始化方法可以等价使用，但：
> 1 当初始值只有一个，拷贝初始化与直接初始化都行，但初始值有多个，一般只能用直接初始化
> 2 如果提供的是一个类内初始值，只能使用拷贝初始化或使用花括号
> 3 如果提供初始元素值的列表，只能在花括号进行列表初始化，不能放在圆括号

```c++
vector<string> v1{"a","an","the"}; //列表初始化
vector<string> v1("a","an","the"); //错误
```

  * 列表初始化

    当用于内置类型的变量时，这种初始化形式有一个重要特点：如果使用初始化列表初始化且初始值存在丢失信息的风险，则编译器报错

  * 默认初始化：如果定义变量时没有指定初值，则变量被默认初始化(default initialized)

    * 内置类型：定义于任何函数体之外，初始化为0；函数体（类）内部的内置类型变量**不被初始化**(uninitialized)，一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝（用int型做测试，g++编译：不报错，但值是随机值）或者以其他形式访问（用指针访问，也不报错，值随机）此类值将引发错误。！！
    * 类的对象如果没有被显示初始化，其值由类决定

```
如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型和变量所在位置决定。

如果是内置类型（int, short等）的变量为被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，**定义在函数体内部的内置变量将不被初始化(uninitialized)，其值时未定义(undefined)的**。
```



####  变量的声明（declaration）

  如果想声明一个变量而非定义它，就在前加extern

```
  extern int i; //声明i而非定义
  int j; //声明并定义j
```

> 变量能且只能被定义一次，但是可以被多次声明

如果在多个文件中使用同一个变量，必须将声明与定义分离。变量的定义必须出现在且只能出现在一个文件中，其他用到该变量的文件必须对其进行声明，但绝不能重复定义。

如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num。
正确的做法是：在任一个文件中定义外部变量num，而在另一文件中用extern对num作外部变量声明。即extern int num;
编译系统由此知道num是一个已在别处定义的外部变量，它先在本文件中找有无外部变量num，如果有，则将其作用域扩展到本行开始。

> par.h

```
#ifndef PAR
#define PAR

int ii=60;

#endif
```

> main.cc

```
#include <iostream>
#include "par.h"

extern int ii;  //将该句注释掉，程序也可以正常运行
int main()
{
    std::cout<<ii<<std::endl;
}
```

> par.h

```
#ifndef PAR
#define PAR

//int ii=60;
extern int ii;
#endif
```

> par.cc

```
#include "par.h"

//extern int ii;
int ii=60;
```

> main.cc

```
#include <iostream>
#include "par.h"

extern int ii;
int main()
{
    std::cout<<ii<<std::endl;
}
```


####  名字的作用域

名字都有作用域。而作用域(scope)是程序的一部分。以花括号分隔

  * 嵌套的作用域
    内层作用域与外层作用域
    * 局部变量会覆盖全局变量
    * 同时存在全局和局部变量时，已定义局部变量的作用域中可用`::reused`显式访问全局变量reused。
    * **但是用到全局变量时，尽量不适用重名的局部变量。**

### 2.3 复合类型

**compound type**

#### 引用

> 一般说的引用是指的左值引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如`int &refVal = val;`。
- 引用**并非对象**，它只是为一个已经存在的对象所起的另外一个名字。因为不是对象，所以不能定义引用的引用。
- 引用必须初始化。
- 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。一旦定义就不能更改绑定为其他的对象
- 并且引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起
- 引用的类型必须和与之绑定的对象严格匹配。
  - 另外1：初始化常量引用时允许用任意表达式做初始值，只要该表达式的结果能转换(convert)成引用类型即可。尤其，允许一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。



#### 指针

> int *p;      //**指向int型对象**的指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。

- 与引用的不同点。

  - 指针本身是一个**对象***，允许对指针进行赋值和拷贝。在指针生命周期内它可以先后指向几个不同的对象
  - 指针无需在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值

- **定义**指针类型： `int *ip1;`，**从右向左读有助于阅读**，`ip1`是指向`int`类型的指针。

- 指针存放某个对象的**地址**。

- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。

- 指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）

  - const是个例外

- 指针的值的四种状态：

  - 1.指向一个对象；

  - 2.指向紧邻对象的下一个位置；

  - 3.空指针；

  - 4.无效指针。

  - >**对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的**

- 指针访问对象： `cout << *p;`输出p指针所指对象的数据， `*`是**解引用符**。

- 空指针不指向任何对象。使用`int *p=nullptr;`来使用空指针。

- > 指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。

- > 赋值语句永远改变的是**左侧**的对象。

- `void*`指针可以存放**任意**对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。

- 其他指针类型必须要与所指对象**严格匹配**。

- 两个指针相减的类型是`ptrdiff_t`。

- 建议：初始化所有指针。

- `int* p1, p2;//*是对p1的修饰，所以p2还是int型`

#### 理解复合类型的声明

- 定义多个变量

```
int i = 1024, *p = &i, &r = i; //i是int型的数，p是int型指针，r是一个int型引用
```



- 指向指针的指针

```c++
int ival = 1024;
int *pi = &ival;
int **ppi = &pi;
```

- 指向指针的引用


### 2.4 const限定符

- 动机：希望定义一些不能被改变值的变量。

#### 1 初始化和const

- const对象**必须初始化**，且**不能被改变**。
- 默认情况下，const对象被设定为仅在文件内有效。多个文件出现了同名const，等于在不同文件中分别定义了独立变量。const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。

#### 2 const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
  - “对const的引用”简称为“常量引用”。只是个简称而已。严格来说，并不存在常量引用 
- 引用的类型必须与其所引用的对象的类型一致。**第一种例外情况就是** 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。code1。只要该表达式能转换成引用类型即可。
  - 理解当一个常量引用被绑定到另外一种类型上时到底发生了什么。code2
    - 编译器创建了临时量对象，ri绑定了一个临时（temporary）对象。
    - 如果ri不是const，如果仍然执行以上操作结果如何？如果ri为非const，则允许对ri赋值，会改变ri所引用的对象的值。但此时ri绑定在临时量上，所以此种行为没有意义，c++将其视为非法，会报错！！！！

> code1

```code1
	int i=42; 
	const int &r1=i;
	const int &r2=42; 
	const int &r3=r1*2
	int &r4=r1*2;//错误，r4是非常量引用
```

> code2

```
double dv=3.14;
const int &ri=dv;

>>>>>>>>>>

const int temp=dv;
const int &ri=temp;
```

- 对const的引用可能引用一个非const对象：常量引用仅对引用可参与的操作做出了限定，对于引用本身是不是一个常量未作限定。
  - 理解：所谓指向常量的指针或引用，不过是指针和引用的“一厢情愿”，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值

```
    int i=42;
    int &r1=i;
    const int &r2=i;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //42 42 42

    r1=0;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //0 0 0
```

> 下面的例子与临时量对象有关

```
    //需要强制类型转换的情况
    double j=42.66;
    const int &r3=j;
    //const int &r2=i;
    std::cout<<j<<","<<r3<<","<<std::endl; //42.66 42

    j=44.66;
    std::cout<<j<<","<<r3<<","<<std::endl; //44.66 42 
    
    
    //不需要强制类型转换的情况
    double i = 10.3;
    const double &i_ = i;
    std::cout<<i<<","<<i_<<","<<std::endl;  //10.3,10.3,   

    i = 12.3;
    std::cout<<i<<","<<i_<<","<<std::endl;  //12.3,12.3  
```

#### 3 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`。
  - 与引用类似，指针的类型必须与所指向对象类型一致，一种例外情况就是允许令一个指向常量的指针指向一个非常量对象
  - double dv=3.14; const double *cp=&dv;//正确，只是不能通过指针修改dv的值 
  - 所谓指向常量的指针或引用，不过是指针和引用的“一厢情愿”，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值
- **const pointer**：指针是对象而引用不是，因此允许把指针本身定义为常量。常量指针必须初始化。指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 `int i = 0; int *const ptr = &i;`
  - 指针本身是个常量，并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。上面的*ptr=1;就可以重新赋值。

#### 4 顶层const

- `顶层const`：指针本身是个常量。更一般的，顶层const可以表示任意的对象是常量
- `底层const`：指针指向的对象是个常量。
  - 拷贝时严格要求相同的底层const资格。

```c++
int i=0;
int *const p1 =&i;   //顶层const
const int ci=42;	 //顶层const
const int *p2=&ci;	 //底层const
const int *const p3=p2; //靠左的const是底层 靠右的const是顶层
const int &r =ci;	 //底层const

//执行拷贝时，常量是顶层还是底层const区别明显，其中，顶层const无影响
//执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没有影响
i=ci;				//正确：拷贝ci，ci是顶层const，对此操作无影响
p2=p3;				//正确：p2 p3指向的对象类型相同，p3顶层const无影响

//执行拷贝时，拷入和拷出对象必须具有相同的底层const，或者两个对象的数据类型必须能转换
//一般来说，非常量可以转换成常量，反之不行
int *p=p3;			//错误：p3包含底层const定义，p没有
p2=p3;				//正确：p2 p3都是底层const
p2=&i;				//正确：int*能转换成const int*
int &r=ci;			//错误：普通int&不能绑定到int常量上
const int &r2=i;	//正确：const int& 可以绑定到普通int上
```

总结：对指针来说，顶层const在赋值拷贝时无影响，主要考虑底层const必须相同！

```c++
const int m = 5;
int * const x = &m; //error，const int*不能转换为int*

const int m = 5;
const int * const x = &m; //right
```





#### 5 `constexpr`和常量表达式（▲可选）

- 常量表达式(const expression)：指值不会改变，且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是否是常量表达式由它的数据类型和初始值共同决定，如：

```c++
const int max_files = 20; //是常量表达式
int staff_size = 27;  //不是常量表达式
const int sz = get_size();  //不是常量表达式
```

- constexpr变量：`C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;         //20是常量表达式
constexpr int limit = mf + 1;  //mf+1是常量表达式
constexpr int sz = size();     //只有当size是一个constexpr函数时，才是一条正确语句
```

如果认定变量是一个常量表达式，就把他声明成constexpr类型

- 字面值类型：算术类型、引用和指针都属于字面值类型
- 指针和constexpr

### 2.5 处理类型

#### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）
- 指针、常量和类型别名

```cpp
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring是char*的别名
const pstring cstr = 0; // 指向char的常量指针
// 如改写为const char *cstr = 0;不正确，为指向const char的指针

// 辅助理解（可代回后加括号）
// const pstring cstr = 0;代回后const (char *) cstr = 0;
// const char *cstr = 0;即为(const char *) cstr = 0;
```

#### auto类型说明符 c++11

- **auto**类型说明符：让编译器**自动推断类型**。auto定义的变量必须有初始值
- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，如果希望是顶层const需要自己加`const`

#### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- 如果对变量加括号，编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。
- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。
- `C++11`

### 2.6 自定义数据类型

#### 类内初始值

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型和变量所在位置决定。

如果是内置类型（int, short等）的变量为被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，**定义在函数体内部的内置变量将不被初始化(uninitialized)，其值时未定义(undefined)的**。

C++11新标准规定可以为数据成员提供一个**类内初始值（in-class initializer）**。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被**默认初始化**。

1、类内初始值和赋值类似，或者放在**花括号里（如数组）**，或者放在**等号右边**，不能使用圆括号。

2、如果在构造方法里面对赋予了类内初始值的变量再次赋值，类内初始值将被覆盖。

```
class Student {
public:
	Student() = default;
	Student(int _age):age(_age) {};
	string name;
	int age = 10;
	int _class {3};
	int grade;
 
	void printInfo() { cout << "age:" << age << ", grade:" << grade << ", class:" << _class << endl; }
};
 
int main() {
	Student student1;
	student1.printInfo();
 
	Student student2(12);
	student2.printInfo();
	return 0;
}
```

上述代码输出：

```
age:10, grade:37, class:3
age:12, grade:24, class:3
```



1）成员变量grade没有被初始化，其值时未定义的，可能为任何值

2）student1对象的age和_class对象均由类内初始值初始化

3）student2对象的age变量的类内初始值被构造方法传递的参数值覆盖



## 第3章 运算符/表达式

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |

### 表达式基础

表达式由一个或多个**运算对象(operand)**组成。字面值和变量是最简单的**表达式(expression)**。把一个**运算符(operator)**和一个或多个运算对象结合起来可以生成复杂的表达式。

#### 基本概念

- c++定义了一元运算符（unary operator）和二元运算符（binary operator）
- **运算对象转换**：小整数类型会被提升为较大的整数类型
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
  - C中原意：左值**可以**在表达式左边，右值不能。
  - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。

#### 优先级与结合律

- **优先级与结合律**

#### 求值顺序

- **求值顺序**：`int i = f1() + f2()`
  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义
  - 有4中运算符明确规定了运算对象的求值顺序
    - && ：它规定了先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧
    - ||
    - (?:)
    - , 

### 运算符
#### 3.1 算术运算符

算术运算符的运算对象和求值结果都是**右值**

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

- **bool类型不应该参与计算**

  ```cpp
  bool b=true;
  bool b2=-b;   //仍然为true
  //b为true，提升为对应int=1，-b=-1
  //b2=-1≠0，所以b2仍未true
  ```

- 取余运算m%n，结果符号与m相同

- 作用：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
//加减乘除
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除结果依然是整数，小数部分舍去
	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl;  //0
	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; //报错，除数不可以为0
	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout << d1 / d2 << endl;  //2。运算的结果也可以是小数
	system("pause");
	return 0;
}
```

> 总结：在除法运算中，除数不能为0




**示例2：**

```C++
//取模
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << 10 % 3 << endl;    //1
	int a2 = 10;
	int b2 = 20;
	cout << a2 % b2 << endl;   //10
	int a3 = 10;
	int b3 = 0;
	//cout << a3 % b3 << endl; //取模运算时，除数也不能为0
	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;
	//cout << d1 % d2 << endl;
	system("pause");
	return 0;
}
```

> 总结：只有整型变量可以进行取模运算


**示例3：**

```C++
//递增
int main() {
	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11
	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11
	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << a2 << endl;  //11
	cout << b2 << endl;  //110
	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << a3 << endl;  //11
	cout << b3 << endl;	 //100
	system("pause");
	return 0;
}
```



> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反








#### 3.2 赋值运算符

- 赋值运算的**返回结果是它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，使用其当条件时应该加括号。
- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响）
  任意复合运算符op等价于`a = a op b;`
  **作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |



**示例：**

```C++
int main() {
	//赋值运算符
	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;
	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl; //12
	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;  //8
	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;
	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;
	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;
	system("pause");
	return 0;
}
```









#### 3.3 比较运算符

运算对象和求值结果都是右值
**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {
	int a = 10;
	int b = 20;
	cout << (a == b) << endl; // 0 
	cout << (a != b) << endl; // 1
	cout << (a > b) << endl; // 0
	cout << (a < b) << endl; // 1
	cout << (a >= b) << endl; // 0
	cout << (a <= b) << endl; // 1
	
	system("pause");
	return 0;
}
```



> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 












#### 3.4 逻辑运算符

运算对象和求值结果都是右值
**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |


- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**

- 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。

```c++
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {
	int a = 10;
	cout << !a << endl; // 0
	cout << !!a << endl; // 1
	system("pause");
	return 0;
}
```

> 总结： 真变假，假变真




**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {
	int a = 10;
	int b = 10;
	cout << (a && b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a && b) << endl;// 0 
	a = 0;
	b = 0;
	cout << (a && b) << endl;// 0
	system("pause");
	return 0;
}
```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==






**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {
	int a = 10;
	int b = 10;
	cout << (a || b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a || b) << endl;// 1 
	a = 0;
	b = 0;
	cout << (a || b) << endl;// 0
	system("pause");
	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==


#### 递增递减运算符

必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置对象则将对象原始值的副本作为右值返回。

* 前置版本`j = ++i`，先加一后赋值
* 后置版本`j = i++`，先赋值后加一
* 后置递增运算符优先级高于解引用运算符 *ptr++ 等价于 *(prt++)


**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

`*iter++`等价于`*(iter++)`，递增优先级较高

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性


#### 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号


#### 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

#### 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

应用：

```c++
unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
1UL << 12;  // 代表第12个学生通过
quiz1 |= (1UL << 12);   // 将第12个学生置为已通过
quiz1 &= ~(1UL << 12);  // 将第12个学生修改为未通过
bool stu12 = quiz1 & (1UL << 12);   // 判断第12个学生是否通过
```

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。


#### 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。


### 类型转换

#### 1 隐式类型转换

> 设计为尽可能避免损失精度，即转换为更精细类型。

下面情况中，编译器会自动地转换运算对象的类型：

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有转换。

##### 1.1 算术转换

算术转换的含义是把一种算术类型转换成另外一种算术类型。前文数据类型中已经提到

- 整型提升

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

##### 1.2 其他转换

> p143

- 数组转换成指针
- 指针的转换
- 转成布尔
- 转成常量：指针与引用。相反不可以，因为它试图删除底层const
- 类类型定义的转换

#### 2 显式类型转换（尽量避免）

强制类型转换cast

##### 命名的强制类型转换

```c++
cast-name<type>(expression)
```

type-目标类型

expression-待转换的值

cast-name:

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

- **dynamic_cast**：支持运行时类型识别。

- **const_cast**：只能改变运算对象的**底层const**，一般可用于去除const性质(cast away the const)。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

##### 旧式强制类型转换

```
type (expr) //函数形式的强制类型转换
(type) expr //c语言风格
```
### 运算符优先级表
p147

## 第4章 程序流程结构（语句）

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码



### 4.1 选择结构（条件语句）

#### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句

- **悬垂else**（dangling else）：用来描述在嵌套的`if else`语句中，如果`if`比`else`多时如何处理的问题。C++使用的方法是`else`匹配最近没有配对的`if`。--使用花括号

1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002.png)

   示例：

   ```C++
   int main() {
   	//选择结构-单行if语句
   	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   	int score = 0;
   	cout << "请输入一个分数：" << endl;
   	cin >> score;
   	cout << "您输入的分数为： " << score << endl;
   	//if语句
   	//注意事项，在if判断语句后面，不要加分号
   	if (score > 600)  //此处如果加分号，大括号内一定会运行
   	{
   		cout << "我考上了一本大学！！！" << endl;
   	}
   	system("pause");
   	return 0;
   }
   ```

   


> 注意：if条件表达式后不要加分号






2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541662519170.png)



示例：

```C++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else
	{
		cout << "我未考上一本大学" << endl;
	}
	system("pause");
	return 0;
}
```











3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541662566808.png)







示例：

```C++
	int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```









**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断



案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。



**示例：**

```c++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
		if (score > 700)
		{
			cout << "我考上了北大" << endl;
		}
		else if (score > 650)
		{
			cout << "我考上了清华" << endl;
		}
		else
		{
			cout << "我考上了人大" << endl;
		}
		
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```







**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/三只小猪.jpg)









#### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {
	int a = 10;
	int b = 20;
	int c = 0;
	c = (a > b ? a : b);
	cout << "c = " << c << endl;
	//C++中三目运算符返回的是变量,可以继续赋值
	(a > b ? a : b) = 100;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	system("pause");
	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰








#### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch(表达式)   //表达式只能为整型或字符型，不可以是区间
{
	case 结果1：执行语句;break;  //若不加break，会继续执行后面的
	case 结果2：执行语句;break;  //执行语句若为多行，必须加{}
	...
	default:执行语句;break;
}
```

- 如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或是遇到一条break为止





**示例：**

```C++
int main() {
	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片
	int score = 0;
	cout << "请给电影打分" << endl;
	cin >> score;
	switch (score)
	{
	case 10:
	case 9:
		cout << "经典" << endl;
		break;   //退出当前分支
	case 8:
		cout << "非常好" << endl;
		break;
	case 7:
	case 6:
		cout << "一般" << endl;
		break;
	default:
		cout << "烂片" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



> 注意1：switch语句中表达式类型只能是整型或者字符型
> 注意2：case里如果没有break，那么程序会一直向下执行
> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间





### 4.2 循环结构

- **while**：当不确定到底要迭代多少次时，使用 `while`循环比较合适，比如读取输入的内容。
- **for**： `for`语句可以省略掉 `init-statement`， `condition`和 `expression`的任何一个；**甚至全部**。
- **范围for**： `for (declaration: expression) statement`

#### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541668640382.png)







**示例：**

```C++
int main() {
	int num = 0;
	while (num < 10)
	{
		cout << "num = " << num << endl;
		num++;
	}
	
	system("pause");
	return 0;
}
```



> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环








**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。



![猜数字](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/猜数字.jpg)

















#### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541671163478.png)



**示例：**

```C++
int main() {
	int num = 0;
	do
	{
		cout << num << endl;
		num++;
	} while (num < 10);
	
	
	system("pause");
	return 0;
}
```



> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件












**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数

将一个多位数每个位置取出： num%10---个位    num/10 %10 （反复做即可）---十位



















#### 4.2.3 for循环语句

**作用：** 满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`
//起始条件可没有

- **范围for**： `for (declaration: expression) statement`

**示例：**

```C++
int main() {
	for (int i = 0; i < 10; i++)
	{
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```







**详解：**

![1541673704101](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/1541673704101.png)



> 注意：for循环中的表达式，要用分号进行分隔
> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用










**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![timg](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/timg.gif)













#### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![1541676003486](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/1541676003486.png)











**示例：**

```C++
int main() {
	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			cout << "*" << " ";
		}
		cout << endl;
	}
	system("pause");
	return 0;
}
```













**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![0006018857256120_b](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/0006018857256120_b.jpg)





### 4.3 跳转语句

- **break**：`break`语句负责终止离它最近的`while`、`do while`、`for`或者`switch`语句，并从这些语句之后的第一条语句开始继续执行。
- **continue**：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在`while`、`do while`、`for`循环的内部。

#### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句

for

while

do while

switch

**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;
	int num = 0;
	cin >> num;
	switch (num)
	{
	case 1:
		cout << "您选择的是普通难度" << endl;
		break;
	case 2:
		cout << "您选择的是中等难度" << endl;
		break;
	case 3:
		cout << "您选择的是困难难度" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout << i << endl;
	}
	system("pause");
	return 0;
}
```



**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	system("pause");
	return 0;
}
```















#### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

for

while

do while

**示例：**

```C++
int main() {
	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;  //进行筛选
		}
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```



> 注意：continue并没有使整个循环终止，而break会跳出循环










#### 4.3.3 goto语句

**作用：**可以无条件跳转语句



**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置



**示例：**

```C++
int main() {
	cout << "1" << endl;
	goto FLAG;
	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;
	FLAG:
	cout << "5" << endl;
	
	system("pause");
	return 0;
}
```



> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱



### 4.4 try语句块和异常处理

- **throw表达式**：异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常。

```c++
if(0)
{
    // 抛出异常并终止当前函数
    throw runtime_error("Data wrong!");
}
```

- **try语句块**：以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为**异常处理代码**。
- **异常类**：用于在 `throw`表达式和相关的 `catch`子句之间传递异常的具体信息。



## 第5章 字符串、向量和数组

### using声明

- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。

### string

- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。

#### 定义和初始化string对象

初始化`string`对象的方式：

| 方式                  | 解释                                                    |
| :-------------------- | ------------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是个空字符串                            |
| `string s2(s1)`       | `s2`是`s1`的副本                                        |
| `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
| `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。

#### string对象上的操作

`string`的操作：

| 操作                 | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
| `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`           | 返回`s`中字符的个数                                          |
| `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
| `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
| `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2`             | 同上                                                         |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

- string io：
  - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
  - `getline`：读取一整行，**包括空白符**。
- `s.size()`返回的时`string::size_type`类型，记住是一个**无符号**类型的值，不要和`int`混用
- `s1+s2`使用时，保证至少一侧是string类型。`string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`
- **字符串字面值和string是不同的类型。**

#### 处理string对象中的字符

- **ctype.h vs. cctype**：C++修改了c的标准库，名称为去掉`.h`，前面加`c`。

  > 如c++版本为`cctype`，c版本为`ctype.h`

  - **尽量使用c++版本的头文件**，即`cctype`

`cctype`头文件中定义了一组标准函数：

| 函数          | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
| `isalpha(c)`  | 当`c`是字母时为真                                            |
| `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
| `isdigit(c)`  | 当`c`是数字时为真                                            |
| `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
| `islower(c)`  | 当`c`是小写字母时为真                                        |
| `isprint(c)`  | 当`c`是可打印字符时为真                                      |
| `ispunct(c)`  | 当`c`是标点符号时为真                                        |
| `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)`  | 当`c`是大写字母时为真                                        |
| `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
| `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
| `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

- 遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符。 （C++11）
- `str[x]`,[]输入参数为`string::size_type`类型，给出`int`整型也会自动转化为该类型

### vector

- vector是一个**容器**，也是一个类模板；
- `#include <vector>` 然后 `using std::vector;`
- 容器：包含其他对象。
- 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。

#### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
| `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
| `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
| `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

- 列表初始化： `vector<string> v{"a", "an", "the"};` （C++11）

#### 向vector对象中添加元素

- `v.push_back(e)` 在尾部增加元素。

#### 其他vector操作

`vector`支持的操作：

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`         | 返回`v`中元素的个数                                          |
| `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
| `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2`         | 同上                                                         |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

### 迭代器iterator

- 所有标准库容器都可以使用迭代器。
- 类似于指针类型，迭代器也提供了对对象的间接访问。

#### 使用迭代器

- `vector<int>::iterator iter`。
- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。
- 养成使用迭代器和`!=`的习惯（泛型编程）。
- **容器**：可以包含其他对象；但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。
- **const_iterator**：只能读取容器内元素不能改变。
- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`
- **谨记**：但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。

标准容器迭代器的运算符:

| 运算符           | 解释                                   |
| ---------------- | -------------------------------------- |
| `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem`      | 等价于`(*iter).mem`                    |
| `++iter`         | 令`iter`指示容器中的下一个元素         |
| `--iter`         | 令`iter`指示容器中的上一个元素         |
| `iter1 == iter2` | 判断两个迭代器是否相等                 |

#### 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符               | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |

- **difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。

### 数组

- 相当于vector的低级版，**长度固定**。

#### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是const表达式，或者不写，让编译器自己推断。
- 数组不允许直接赋值给另一个数组。

#### 访问数组元素

- 数组下标的类型：`size_t` 。
- 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。

#### 数组和指针

- 使用数组时，编译器一般会把它转换成指针。
- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 
- **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。

### C风格字符串

- 从C继承来的字符串。
- 用空字符结束（`\0`）。
- 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效。
- 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 。

C标准库String函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

 **尽量使用vector和迭代器，少用数组**

### 多维数组

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...}`。
- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。

### 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

### 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

### 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。





## 第6章 函数




### 6.1 函数基础

- **函数定义**：包括返回类型(return type)、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体(function body)。

```C++
返回值类型 函数名 （参数列表）
{
       函数体语句
       return表达式
}
```

- **调用运算符**(call operator)：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
  - 执行函数的第一步是（隐式）定义并初始化它的形参
- **形参和实参**：实参是形参的初始值。形参和实参的**个数**和**类型**必须匹配上。
- 函数的形参列表： 
```c++
void f() {}		//隐式定义空形参列表
void f(void) {} //显式定义空形参列表
```
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型**不能是数组类型或者函数类型**，**但可以是指向数组或者函数的指针**。



#### 局部对象

- **生命周期**(lifetime)：对象的生命周期是程序执行过程中该对象存在的一段时间。（名字有作用域）
	- 名字的作用域是程序文本的一部分，名字在其中可见
	- 对象的声明周期是程序执行过程中该对象存在的一段时间
	- **局部变量**（local variable）。函数体是一个语句块。块构成一个新的作用域。形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的。同时局部变量会**隐藏**（hide）在外层作用域中的同名的其他所有声明。
- **自动对象**（automatic object）：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
	- 形参是一种自动对象。
	- 用传递给函数的实参初始化形参对应的自动对象。局部变量对应的自动对象，分两种情况：如果变量定义本身函数初始值，则初始化；否则，执行默认初始化，这意味着，内置类型的未初始化的局部变量将产生未定义的值。
- **局部静态对象**（local static object）： `static`类型的局部变量，生命周期贯穿函数调用前后。直到程序终止被销毁

#### 函数声明

- **函数声明**：函数的名字也必须在使用前声明。函数的声明和定义唯一的区别是声明无需函数体，也无须形参的名字，用一个分号替代。
	- 函数声明主要用于描述函数的三要素（返回类型、函数名、形参类型）即定义了函数的接口，也称**函数原型**（function prototype）。
	- 函数的声明不包含函数体，所以无须形参的的名字
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**（separate compilation）： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

### 6.2 参数传递

- 每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。形参初始化的机理和变量初始化一样
- 如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

#### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。
	- 指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。
```c++
#include <iostream>
void fun(int *a)
{
	int i ;
	std::cout<<"i:"<<i<<std::endl;
	int j = i;
	std::cout<<"j:"<<j<<std::endl;
	int *p = &i;
	std::cout<<"*p:"<<*p<<std::endl;	
	int b = 5; 
	a = &b;
	*a = 6;
	//int b = 5; 
	//a = &b;
}
void fun1(int *a)
{
	int i ;
	std::cout<<"i:"<<i<<std::endl;
	int j = i;
	std::cout<<"j:"<<j<<std::endl;
	int *p = &i;
	std::cout<<"*p:"<<*p<<std::endl;	 
	*a = 6;
	int b = 5; 
	a = &b;
}
int main()
{
	int temp = 9;
	fun(&temp);
	std::cout<<"temp:"<<temp;
	fun1(&temp);
	std::cout<<"temp:"<<temp;
	return 0;
}
```

```
i:0
j:0
*p:0
temp:9
i:32766
j:32766
*p:32766
temp:6
```



#### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用避免拷贝
	- 当某种类型不支持拷贝时，函数只能通过引用访问
	- 经常用引用形参来避免不必要的复制。
	- 如果无需改变引用形参的值，最好将其声明为**常量引用**。
- 使用引用形参可以用于**返回额外的信息**。
```
void swap(int &v1, int &v2)
```

#### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。
	- 把函数不会改变的形参定义成（普通）引用是一种比较常见的错误
	- 以上做法带给调用者一种误导，即函数可以修改它的实参的值
	- 此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。
	- 例如，我们不能讲const对象、字面值或者需要类型转换的对象传递给普通的引用形参

#### 数组形参

- 数组有两个性质：不允许拷贝数组、使用数组时通常会将其转换成指针。
- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针；无法以值传递的方式使用数组参数。
- 管理数组形参有三种方法：
	- 1 使用标记指定数组长度：数组本身包含结束标记；
	- 2 使用标准库规范：传递指向数组首尾元素的指针；
	- 3 显示传递一个表示数组大小的形参：专门定义表示数组大小的形参。
- 允许将变量定义成数组的引用
	- f(int &arr [10])   //错误，将arr声明成了引用的数组
	- f(int (&arr) [10])  //正确，arr是具有10个整数的整型数组的引用
- 传递多维数组。

```
int *matrix[10];   //10个指针构成的数组
int (*matrix)[10]; //指向含有10个整数的数组的指针
```

#### main处理命令行选项

有时需要给main函数传递实参。假定main函数位于可执行文件prog内

```
prog -d -o ofile data0
```

- `int main(int argc, char *argv[]){...}`
- `int main(int argc, char **argv){...}`
- 第一个形参，表示数组中字符串的数量，代表参数的个数；第二个形参是参数C风格字符串数组。
- 当实参传递给函数后，argv的第一个元素指向程序的名字或者一个空字符串。接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素保证为0.

```c++
int main(int argc,char **argv)
{
const int m = 5;
const int * const x = &m; //right
        std::cout<<"m:"<<m<<std::endl;
        std::cout<<"argv[0]:"<<argv[0]<<std::endl;
        std::cout<<"argv[1]:"<<argv[1]<<std::endl;
        std::cout<<"argv[2]:"<<argv[2]<<std::endl;
        std::cout<<"argv[3]:"<<argv[3]<<std::endl;
        std::cout<<"argv[4]:"<<argv[4]<<std::endl;
        std::cout<<"argv[5]:"<<argv[5]<<std::endl;
        return 0;
}
```

```
casicapollo@casicapollo-System-Name:~/Documents/test$ ./a.out -d -o ofile data0
m:5
argv[0]:./a.out
argv[1]:-d
argv[2]:-o
argv[3]:ofile
argv[4]:data0
argv[5]:
```



#### 含有可变形参的函数

有时我们无法提前预知应该向函数传递几个参数。

为了编写能处理不同数量实参的函数，C++11提供了两种主要方法：所有的实参类型相同，initializer_list ；实参类型不同， 可变参数模板 ；还有省略符，一般只用于与C函数交互的接口程序

1. `initializer_list`提供的操作（`C++11`）：

实参数量未知但全部实参的类型相同，可以使用 `initializer_list`的标准库类型。

initializer_list对象中的元素永远是常量值

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay"});
```



2. 实参类型不同，可以使用`可变参数模板`。
3. 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。



### 6.3返回类型和return语句

return语句有两种形式

```c++
return;

return expression;

```

#### 无返回值函数

- 没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

- void函数如果想在中间位置提前退出，可以使用return语句，此时return类似于break。
- 一个返回类型是void的函数也能用return语句的第二种形式，不过此时return中的expression必须是另一个返回void的函数

#### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值如何被返回
	- 返回一个值的方式和初始化一个变量或形参的方式完成一样
	- 返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
```c++
const string &manip()
{
	string ret;
	if(!ret.empty())
	{
		return ret;    //error:返回局部对象的引用
	}else{
		return "Empty";//error:“Empty”是一个局部临时变量
	}
}
```
- 返回类类型的函数和调用运算符
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。可以像使用其他左值那样来使用**返回引用的函数的调用**，即能为返回类型是非常量引用的函数的结果赋值。
- **列表初始化返回值**：（`C++11`）函数可以返回花括号包围的值的列表。
```c++
vector<string> process()
{
    if()
    {
        return {};              // 返回空vector
    }else if(){
        return {"fun","okay"};  //返回列表初始化的vector   
    }else{
        return {"fun","okay","oo"};
    }
}
```

- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。

#### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。可以返回数组的指针或引用

```c++
typedef int arrT[10]; //arrT是类型别名，它表示的类型是含有10个int的数组
using arrT=int [10];  //arrT的等价声明
arrT* func(int i);    //func 返回一个指向含有10个int的数组的指针
```

```c++
int arr[10]; 
int *p1[10]; //p1是含有10个指针的数组
int (*p2)[10] =&arr;  //p2是一个指针，指向含有10个int的数组
```

- 声明一个返回数组指针的函数
	- 返回数组指针的函数形式：`Type (*function (parameter_list))[dimension]`
	- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10]；`，然后 `arrT* func() {...}`
	- 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

### 6.4 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
	- `main`函数不能重载。
- **函数重载满足条件：**

  * 同一个作用域下
  * 函数名称相同
  * 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**
- 判断两个形参是否相同
- **重载和const形参**：
  - 一个有顶层const的形参和另一个没有顶层const的形参，函数无法区分。
```c++
Record lookup(Phone* const)
Record lookup(Phone*)    //重复声明

Record lookup(const Phone)
Record lookup(Phone)     //重复声明
```
  - 相反，如果形参是指针或引用，通过区分其指向的是常量对象还是非常量对象可以实现函数重载，const是底层的。 
```c++
Record lookup(Account*)
Record lookup(const Account*)  //可以区分。

Record lookup(Account&)
Record lookup(const Account&)  //可以区分。
```
- const_cast和重载

```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1:s2;
}
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string &>(s1),
                           const_cast<const string &>(s2));
    return const_cast<string&>(r);
}
```

首先将实参强转成const引用，然后调用shorterString的const版本，返回const string引用，然后将其转回一个普通string&

- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。

### 6.5 特殊用途语言特性

#### 默认实参

- default argument
```c++
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```
- 在给定的作用域中一个形参只能被赋予一次默认实参。
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：` 返回值类型  函数名 （参数= 默认值）{}`

**示例：**

```C++
int func(int a, int b = 10, int c = 10) {
	return a + b + c;
}

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
	return a + b;
}

int main() {

	cout << "ret = " << func(20, 20) << endl;
	cout << "ret = " << func(100) << endl;

	system("pause");

	return 0;
}
```



#### 内联（inline）函数和constexpr函数
- inline
	- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
	- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
	- `inline`函数应该在头文件中定义。

- constexpr函数

	- 指能用于常量表达式的函数。
	- 函数的返回类型及所有形参类型都要是字面值类型，且函数体内有且只有一个return
	- `constexpr int new_sz() {return 42;}`
	- `constexpr`函数应该在头文件中定义。

#### 调试帮助assert

https://www.runoob.com/w3cnote/c-assert.html

- `assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```



assert() 的用法像是一种"契约式编程"，其表达的意思就是，程序在假设条件下，能够正常良好的运作，其实就相当于一个 if 语句：

```
if(假设成立)
{
     程序正常运行；
}
else
{
      报错&&终止程序！（避免由程序运行引起更大的错误）  
}
```

但是这样写的话，就会有无数个 if 语句，甚至会出现，一个 if 语句的括号从文件头到文件尾，并且大多数情况下，我们要进行验证的假设，只是属于偶然性事件，又或者我们仅仅想测试一下，一些最坏情况是否发生，所以这里有了 assert()。

assert 宏的原型定义在 assert.h 中，其作用是如果它的条件返回错误，则终止程序执行。

```
#include "assert.h" 
void assert( int expression );
```

assert 的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。

使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。 

在调试结束后，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用，示例代码如下： 

```
#include 
#define NDEBUG 
#include
```

**用法总结与注意事项**

**1)在函数开始处检验传入参数的合法性** 

如: 

```
int resetBufferSize(int nNewSize) 
{ 
//功能:改变缓冲区大小, 
//参数:nNewSize 缓冲区新长度 
//返回值:缓冲区当前长度 
//说明:保持原信息内容不变 nNewSize<=0表示清除缓冲区 
assert(nNewSize >= 0); 
assert(nNewSize <= MAX_BUFFER_SIZE); 
 
... 
}
```

**2)每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败** 

不好: 

```
assert(nOffset>=0 && nOffset+nSize<=m_nInfomationSize); 
```

好:

```
assert(nOffset >= 0); 
assert(nOffset+nSize <= m_nInfomationSize); 
```

**3)不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题** 

错误: assert(i++ < 100) 

这是因为如果出错，比如在执行之前i=100,那么这条语句就不会执行，那么i++这条命令就没有执行。 

正确: 

```
assert(i < 100)
i++; 
```

**4)assert和后面的语句应空一行,以形成逻辑和视觉上的一致感** 

**5)有的地方,assert不能代替条件过滤** 　　 

程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。断言assert  是仅在Debug 版本起作用的宏，它用于检查"不应该"发生的情况。以下是一个内存复制程序，在运行过程中，如果assert  的参数为假，那么程序就会中止（一般地还会出现提示对话，说明在什么地方引发了assert）。 

**以下是使用断言的几个原则：** 

- （1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。 
- （2）使用断言对函数的参数进行确认。 
- （3）在编写函数时，要进行反复的考查，并且自问："我打算做哪些假定？"一旦确定了的假定，就要使用断言对假定进行检查。
- （4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果"不可能发生"的事情的确发生了，则要使用断言进行报警。 

ASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0),  程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。  

ASSERT 只有在 Debug 版本中才有效，如果编译为 Release 版本则被忽略。  

### 6.6 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

### 6.7 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。



## 第7章 类和对象

初始化

拷贝

赋值

销毁

### 7.1 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。

#### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

#### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`
- `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
  - `return *this;`可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

#### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。

#### 类的构造函数



### 7.2 构造与析构

初始化

拷贝

赋值

销毁

#### 7.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



c++利用了**构造函数constructor**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**

类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员。



* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次



#### 7.2.2 构造函数的分类及调用

**1. 两种分类方式：**

- 按参数分为： 
	- 有参构造
	- 无参构造（默认构造）：对参数进行默认初始化。
	- 如果类没有显式定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数，该函数被称为**合成的默认构造函数synthesized default constructor**
		- 如果存在类内初始值，用它来初始化成员
		- 否则，默认初始化该成员（随机值）
	- 某些类不能依赖于合成的默认构造函数
		- 只有当类没有生明任何构造函数时，编译器才会自动生成默认构造
		- 如果类包含内置类型或者复合类型成员，只有当这些成员全被赋予类内初始值，这个类才适合用于使用合成的默认构造函数
		- 有时候编译器不能为某些类合成默认的构造函数。如果类中包含一个其他类类型的成员，并且这个成员的类型没有默认构造函数，那么编译器无法初始化该成员。
- 按类型分为： 
	- 普通构造
	- 和拷贝构造
- 委托构造函数
- **类内初始值**：必须使用=的初始化形式或者花括号括起来的直接初始化形式



**2. 三种调用方式：**

- 括号法

- 显示法

- 隐式转换法



**3. =default的含义**

- 它是一个默认构造函数。
- C++11中，如果我们需要默认的构造函数，就可以通过在参数列表后写上=default来要求编译器生成构造函数。



**4. 委托构造函数**：使用它**所属类**的**其他构造函数**执行它的初始化过程。

- 委托构造函数将自己的职责委托给了其他构造函数。
- `Sale_data(): Sale_data("", 0, 0) {}`

```c++
#include <string>

class Sales_data
{
private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
public:
    // 非委托
    Sales_data(std::string s, unsigned cnt, double price):
            bookNo(s), units_sold(cnt), revenue(cnt*price){}
    // 其余构造函数全都委托给另一个构造函数
    Sales_data(): Sales_data("",0,0){}
    Sales_data(std::string s):Sales_data(s,0,0) {}
    Sales_data(std::istream &is) : Sales_data()
        { read(is,*this);}
};

```



**5. 隐式的类型转换**

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。

```
//Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。在需要使用Sales_data的地方，可以使用string和istream替代
string null_book = "9-999-9999";
// 构造一个临时的Sales_data对象
item.combine(nullbook);
```

这里我们用string实参调用了Sales_data的combine成员。编译器用给定的string自动创建一个Sales_data对象

- 编译器只会自动地执行`仅一步`类型转换。

```
//错误：需要用户定义的两种转换：
//1 把"9-999-9999"转换成string
//2 把这个（临时的）string转换成Sales_data
item.combine("9-999-9999")

//正确，显示转换成string，隐式转换成Sales_data
item.combine(string("9-999-9999"));
//正确，隐式转换成string，显示转换成Sales_data
item.combine(Sales_data("9-999-9999"))
```

- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。只能在类内声明构造函数时使用explicit关键字
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

```c++
class Sales_data{
public:
    Sales_data() = default;
    explict Sales_data(const std::string &s): bookNo(s){};
}
```

此时，没有任何构造函数能够隐式创建Sales_data，下面用法失效

```c++
string null_book = "9-999-9999";
item.combine(nullbook);   //error
```

发生隐式转换的一种情况是我们执行拷贝初始化时（使用=），`explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

```
//发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=），此时我们只能使用直接初始化而不能使用explicit构造函数：
Sales_data item1(null_book); //正确，直接初始化
Sales_data item2 = null_book; //错误，不能将explicit构造函数用于拷贝形式的初始化过程
```

- 为转换显式地使用构造函数

```
item.combine(Sales_data(nullbook));  //right
```



**示例：**

```C++
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system("pause");

	return 0;
}
```

1. 括号法 
   Person p(10);

2. 显示法
   Person p=Person(10);

3. 隐示转换法（只有一个参数的构造函数）
   Person p=10;

4. explict关键字：即3无效
   explict只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显示的，而非隐示的，跟它相对的是implict，即隐式的，类构造函数默认声明为implict
   构造函数参数>=2,无法发生隐式转换，explict失效

  **该关键字还在转换函数的时候用到，用来表示类型转换无效！！！！！！！！！**



#### 7.2.3 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行**值拷贝**



构造函数调用规则如下：

* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造


* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数



示例：

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 7.2.4 拷贝构造函数调用时机



C++中**拷贝构造函数**调用时机通常有三种情况

* 使用一个已经创建完毕的对象来初始化一个新对象（初始化变量）
* 值传递的方式给函数参数传值
* 以值方式返回局部对象



当我们使用赋值运算符时会发生对象的赋值操作。



**示例：**

```C++
class Person {
public:
	Person() {
		cout << "无参构造函数!" << endl;
		mAge = 0;
	}
	Person(int age) {
		cout << "有参构造函数!" << endl;
		mAge = age;
	}
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int *)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout << (int *)&p << endl;
}

int main() {
	//test01();
	//test02();
	test03();
	system("pause");
	return 0;
}
```



#### 7.2.5 深拷贝与浅拷贝



深浅拷贝是面试经典问题，也是常见的一个坑



浅拷贝：简单的赋值拷贝操作



深拷贝：在堆区重新申请空间，进行拷贝操作

**示例1：**

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ) {	
		cout << "有参构造函数!" << endl;
		m_age = age;	
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int m_age;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);  //括号法调用拷贝构造

	cout << "p1的年龄： " << p1.m_age  << endl;

	cout << "p2的年龄： " << p2.m_age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```


**示例2：**
增加堆区的成员变量
但此时在析构函数中没有delete操作，所以此时不报错

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**示例3：**
增加析够，此时报错了

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
			m_height=NULL;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



| p1                                     |                                                      | p2                                 |
| -------------------------------------- | ---------------------------------------------------- | ---------------------------------- |
| int m_age                              | Person p2(p1)                                        | int m_age                          |
| 18                                     | 如果利用编译器提供的拷贝构造，做前拷贝，直接逐字复制 | 18                                 |
| int* m_Height                          | 堆区                                                 | int* m_Height                      |
| 0x0011                                 | 0x0011  160                                          | 0x0011                             |
| p1后被释放，再次释放堆区内存，出现错误 | 浅拷贝带来的问题就是堆区内存重复释放                 | p2先被释放，将堆区释放，此时没问题 |
|                                        | 浅拷贝的问题要通过深拷贝来解决                       |                                    |
|                                        | 0x0022 160                                           | int* m_Height                      |

**示例4：**
提供拷贝构造

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		//这一句为编译器提供
		//m_Height=p.m_Height;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题





#### 7.2.6 初始化列表

对于对象的数据成员，初始化和赋值与变量类似，是两个不同的过程。

如果没有在构造函数的***初始值列表中***显示地初始化成员，则该成员将在***构造函数体之前***执行默认初始化。

即：初始化列表就相当于变量初始化

**作用：**

C++提供了初始化列表语法，用来初始化属性。

**并且有一些情况下，构造函数的初始值必不可少。**

- 成员是const、引用
- 属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`

**注意**：

- 成员初始化顺序
	- 最好让构造函数初始值的顺序和成员声明的顺序保持一致。尽量避免用某些成员初始化其他成员。
```C++
class X
{
	int i;
    int j;
public:
    // 未定义的：i在j之前被初始化
    X(int val):j(val),i(j){}
    
}
```
- 默认实参与构造函数
	- 如果一个构造函数为所有参数都提供了默认实数，那么它实际上也定义了默认的构造函数。



**示例：**

```C++
class Person {
public:

	////传统方式初始化
	//Person(int a, int b, int c) {
	//	m_A = a;
	//	m_B = b;
	//	m_C = c;
	//}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	void PrintPerson() {
		cout << "mA:" << m_A << endl;
		cout << "mB:" << m_B << endl;
		cout << "mC:" << m_C << endl;
	}
private:
	int m_A;
	int m_B;
	int m_C;
};

int main() {

	Person p(1, 2, 3);
	p.PrintPerson();


	system("pause");

	return 0;
}
```


> 初始化列表性能好，推荐使用
> 必须使用初始化列表的时候：
> 1）常量成员const
> 2）引用 。以上两种均为只可以初始化不可以赋值的情况
> 3）没有默认构造函数的类（自定义）类型：直接调用拷贝构造

> 构造函数执行其实是分为两个阶段的：1）初始化阶段；2）普通的计算阶段阶段。
> 初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。计算阶段：一般用于执行构造函数体内的赋值操作
> 1)初始化阶段:初始化列表中显示初始化的成员按照列表中圆括号内的值初始化，而对于初始化列表中没有显式列出的成员，若是类成员，则调用该类型的默认构造函数初始化，若是内置类型或者复合类型，则按照变量初始化的原则，在局部作用域中的不做初始化，全局作用于中的初始化为0。
> 2)普通的计算阶段：一般是指在构造函数的函数体内对数据成员做赋值工作，千万记住，在函数体内进行赋值操作之前，数据成员的初始化已经完成。

https://blog.csdn.net/weixin_34260991/article/details/92153995

    使用常规构造函数赋值类对象：

```
#include <iostream>
using namespace std; 
 
class Test_A
{
public:
	Test_A()
	{
		cout<<"构造函数Test_A()"<<endl;
	}
 
	Test_A(const Test_A& t1)
	{
		cout<<"拷贝构造函数Test_A()"<<endl;
		m_age = t1.m_age;
	}
 
	Test_A& operator = (const Test_A& t1)
	{
		cout<<"重载赋值运算符operator="<<endl;
		m_age = t1.m_age;
		return *this;
	}
 
	~Test_A()
	{
		cout<<"析构函数~Test_A()"<<endl;
	}
public:
	int m_age;
};
 
class Test_B
{
public:
	Test_B(Test_A& t1)
	{
		m_b = t1;
	}
public:
	Test_A m_b;
};
 
/*此函数相当于一个舞台，展示此函数内对象的完整生命周期*/
void display() 
{
	Test_A t1;
	Test_B t2(t1);
}
 
int main()
{
	display();
	system("pause");
	return 0;
}
```

    输出结果：
    构造函数Test_A()
    构造函数Test_A()
    重载赋值运算符operator=
    析构函数~Test_A()
    析构函数~Test_A()

从输出结果中可以看出，在执行Test_B t2(t1)的过程：
先调用Test_A类的构造函数初始化成员对象 m_b                             （初始化阶段）
然后再调用Test_A类的重载赋值运算符函数，将t1赋值给m_b。    （计算阶段）

    使用初始化列表（只需修改类Test_B中的构造函数）：

```
class Test_B
{
public:
	Test_B(Test_A& t1):m_b(t1){};   //使用了构造函数的初始化列表
public:
	Test_A m_b;
};
```

```
输出结果：
构造函数Test_A()
拷贝构造函数Test_A()
析构函数~Test_A()
析构函数~Test_A()
```



### 7.3 this指针

#### 7.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

```C++
class Person {
public:
	Person() {
		mA = 0;
	}
	//非静态成员变量占对象空间
	int mA;
	//静态成员变量不占对象空间
	static int mB; 
	//函数也不占对象空间，所有函数共享一个函数实例
	void func() {
		cout << "mA:" << this->mA << endl;
	}
	//静态成员函数也不占对象空间
	static void sfunc() {
	}
};

int main() {

	cout << sizeof(Person) << endl;

	system("pause");

	return 0;
}
```



#### 7.3.2 this指针概念

在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

A：c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个**非静态成员函数**内的一种指针

this指针不需要定义，直接使用即可

`*this`：

- 每个成员函数都有一个额外的，隐含的形参`this`。
- `this`总是指向当前对象，因此`this`是一个常量指针。
- 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
- `return *this;`可以让成员函数连续调用。
- 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
- `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

this指针的用途：

*  当形参和成员变量同名时，可用this指针来区分  （解决名称冲突）
*  在类的非静态成员函数中返回对象本身，可使用return *this （链式编程。返回对象本身，this指针指向被调用的成员函数所属的对象）

```C++
class Person
{
public:
	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}
	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//this指向p2的指针，*this返回对象本身
		return *this;
	}
	int age;
};

void test01()
{
	Person p1(10);
	cout << "p1.age = " << p1.age << endl;

	Person p2(10);

	//链式编程思想
	//如果上面返回的不是Person& 而是Person，输出为20
	//如果返回值为Person类型，即值传递，那么会调用拷贝构造
             返回p2`               返回p2``             返回p2```
   (             |	     )                    )                   )
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout << "p2.age = " << p2.age << endl;
}

int main() {

	test01();
	system("pause");
	return 0;
}
```



```
total.isbn();  //返回bookNo
```

当我们在调用成员函数时，实际上是在替某个对象调用它。在上面的调用中，实际上隐式地返回total.bookNo。

成员函数通过一个名为**this**的额外的隐式参数来访问**调用它的那个对象**。当我们调用一个成员函数时，用请求该函数的对象的地址初始化this。即

```c++
total.isbn()

Sales_data::isbn(&total)//伪代码
```

在成员函数内部，可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。**任何对类成员的直接访问都被看做this的隐式引用**。

因为this总是指向该对象，所以this是一个常量指针，不允许改变this中保存的地址。





#### 7.3.3 const修饰成员函数



**常函数：**

* 成员函数后加const后我们称为这个函数为**常函数**（常量成员函数）
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改



const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向 类 类型 的 非常量版本 的 常量指针 。 AA * const this

尽管this是隐式的，但仍然需要遵守初始化规则，意味着（在默认情况下）我们不能将this绑定到一个常量对象上（指针指向的对象必须与指针的类型相同。可以用非const来初始化const指针，但反过来不行，此处的情况就是反过来，用const来初始化非const指针）。因此，**不能在一个常量对象上调用普通的成员函数**。

常函数（常量成员函数const member function），加了const之后，this变成 const AA * const this，此时this可以绑定常量对象。

```
常量对象，以及常量对象的引用或指针都只能调用常量成员函数
```



**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数
* 成员属性声明时加关键字mutable后，常对象可以修改

成员属性声明时加关键字mutable后，在常函数中也可以修改



**示例：**

```C++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	//在成员函数后加const，修饰的是this指向，让指针指向的值也不可以修改
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用非const的函数，因为普通成员函数可以修改属性

}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 7.3.4 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

**示例：**

```C++
//空指针访问成员函数
class Person {
public:

	void ShowClassName() {
		cout << "我是Person类!" << endl;
	}
	
	//1.0
	void ShowPersonAge() {
		cout << mAge << endl;
	}
	//2.0
	void ShowPersonAge() {
		if (this == NULL) {
			return;
		}
		cout << mAge << endl;
	}


public:
	int mAge;
};

void test01()
{
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
	p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
					//属性前默认加了this指针，而this是空的，空的指针访问属性，必报错
}

int main() {

	test01();

	system("pause");

	return 0;
}
```







### 7.4 访问控制与封装、友元

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

- 允许特定的**非成员函数**访问一个类的**私有成员**.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 通常将友元声明成组地放在**类定义的开始或者结尾**。
- 类之间的友元：
  - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

友元的目的就是让一个函数或者类 访问另一个类中私有成员



友元的三种实现

* 全局函数做友元
* 类做友元
* 成员函数做友元

##### 全局函数做友元

```C++
class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	friend void goodGay(Building * building);
public:
	Building()
	{
		this->m_SittingRoom = "客厅";
		this->m_BedRoom = "卧室";
	}

public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};

void goodGay(Building * building)
{
	cout << "好基友正在访问： " << building->m_SittingRoom << endl;
	cout << "好基友正在访问： " << building->m_BedRoom << endl;
}

void test01()
{
	Building b;
	goodGay(&b);
}

int main(){
	test01();
	system("pause");
	return 0;
}
```



##### 类做友元

```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	friend class goodGay;
public:
	Building();
public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){
	test01();
	system("pause");
	return 0;
}
```



##### 成员函数做友元

```C++
class Building;
class goodGay
{
public:
	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 
private:
	Building *building;
};

class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	friend void goodGay::visit();
public:
	Building();
public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void goodGay::visit2()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	//cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system("pause");
	return 0;
}
```



#### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

### 7.5 类的其他特性

#### 类成员

- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。
- **可变数据成员** （mutable data member）：
  - `mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。

#### 类类型
- **类类型**：
  - 每个类定义了唯一的类型。

C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员



例如：

```C++
class A {}
class B
{
    A a；
}
```



B类中有对象A作为成员，A为对象成员



那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

> 当类中成员是其他类对象时，我们称该成员为 对象成员
> 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
> 析构顺序与构造相反





**示例1：**
初始化列表

```C++
class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
	}


	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	//Phone m_Phone = pName;//隐式转换法
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三" , "苹果X");

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**示例2：**

```C++
class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
		cout << "Phone构造" << endl;
	}

	~Phone()
	{
		cout << "Phone析构" << endl;
	}

	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout << "Person构造" << endl;
	}

	~Person()
	{
		cout << "Person析构" << endl;
	}

	void playGame()
	{
		cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl;
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三" , "苹果X");
	p.playGame();

}


int main() {

	test01();

	system("pause");

	return 0;
}
```





### 7.6 类的作用域 

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。



### 7.7 类的静态成员

- 非`static`数据成员存在于类类型的每个对象中。
- `static`数据成员独立于该类的任意对象而存在。
- 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。

有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

在成员声明之前加static使得其与类关联在一起。

**静态成员**就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：
（均有访问权限private public）

*  静态成员变量
   *  所有对象共享同一份数据  //改一个全改//访问方式两种
   *  在编译阶段分配内存 全局区
   *  类内声明，类外初始化
*  静态成员函数
   *  所有对象共享同一个函数 //两种访问方式
   *  静态成员函数只能访问静态成员变量 //无法区分到底是哪个对象的非静态成员变量

静态成员函数不与任何对象绑定在一起，**不包含this指针**。**静态成员函数不能声明成const的**，也不能在static函数体内使用this指针



- 声明：
  - 声明之前加上关键词`static`。
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
- 定义：
  - 在类外部定义时不用加`static`。
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义，则要求必须是字面值常量类型的`constexpr`。





**示例1 ：**静态成员变量

```C++
class Person
{
	
public:

	static int m_A; //静态成员变量

	//静态成员变量特点：
	//1 在编译阶段分配内存
	//2 类内声明，类外初始化
	//3 所有对象共享同一份数据
	//4 有访问权限

private:
	static int m_B; //静态成员变量也是有访问权限的
};
int Person::m_A = 10;
int Person::m_B = 10;

void test01()
{
	//静态成员变量 不属于某个对象，所有对象共享同一份数据
	//因此，静态成员变量两种访问方式
	//1 通过对象
	//2 通过类名

	//1、通过对象
	Person p1;
	p1.m_A = 100;
	cout << "p1.m_A = " << p1.m_A << endl;   //100

	Person p2;
	p2.m_A = 200;
	cout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据 //200
	cout << "p2.m_A = " << p2.m_A << endl;

	//2、通过类名
	cout << "m_A = " << Person::m_A << endl;

	//cout << "m_B = " << Person::m_B << endl; //私有权限访问不到
}

int main() {
	test01();
	system("pause");
	return 0;
}
```



**示例2：**静态成员函数

```C++
class Person
{

public:

	//静态成员函数特点：
	//1 程序共享一个函数
	//2 静态成员函数只能访问静态成员变量
	
	static void func()
	{
		cout << "func调用" << endl;
		m_A = 100;   //静态成员函数可以访问静态成员变量
		//m_B = 100; //错误，静态成员函数不可以访问非静态成员变量
	}

	static int m_A; //静态成员变量
	int m_B; // 
private:

	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "func2调用" << endl;
	}
};
int Person::m_A = 10;


void test01()
{
	//静态成员函数两种访问方式

	//1、通过对象
	Person p1;
	p1.func();

	//2、通过类名
	Person::func();


	//Person::func2(); //私有权限访问不到
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

### 静态static总结

https://blog.csdn.net/ypshowm/article/details/89030194
https://blog.csdn.net/majianfei1023/article/details/45290467

c++static关键字的作用
c/c++共有
1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。               
2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。              
3）：修饰函数时，表明该函数只在同一文件中调用。
c++独有：
4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。
5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

1. C 语言的 static 关键字有三种（具体来说是两种）用途：
   1.1. 静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。

```c++
int foo(){
	static int i = 1; // note:1
	//int i = 1;  // note:2
	i += 1;
	return i;
}
```

要明白这个用法，我们首先要了解c/c++的内存分布，以及static所在的区间。

对于一个完整的程序，在内存中的分布情况如下图：　 
1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
3.堆区：程序员分配并释放的区域，像malloc(c),new(c++) 
3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
4.代码区

Q:所以上面note:1的static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？
A:首先回答第一个问题：它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么i就是在栈区分配了，会随着foo的调用结束而释放)。
那么第二个问题也就浮出水面了，它是在第一次调用进入note:1的时候初始化（当初面试被坑过，我居然说是一开始就初始化了，汗！！）。且只初始化一次，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。

那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：
（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);
（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);
（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);
（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);

1.2 静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。


```
static int i = 1;  //note:3
//int i = 1;  //note:4
 
 
int foo()
{
	i += 1;
	return i;
}
```

note:3和note:4有什么差异呢？你调用foo(),无论调用几次，他们的结果都是一样的。也就是说在本文件内调用他们是完全相同的。那么他们的区别是什么呢？
文件隔离！

假设我有一个文件a.c,我们再新建一个b.c,内容如下。

```
//file a.c
 
//static int n = 15;  //note:5
int n = 15;  //note:6
 
//file b.c
#include <stdio.h>
 
extern int n;
//extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
void fn()
{
	n++;
	printf("after: %d\n",n);
}
 
 
void main()
{
	printf("before: %d\n",n);
	fn();
}
```

我们先使用note:6,也就是非静态全局变量，发现输出为:
before: 15
after: 16


也就是我们的b.c通过extern使用了a.c定义的全局变量。
那么我们改成使用note:5,也就是使用静态全局变量呢？

gcc a.c b.c -o output.out

会出现类似undeference to "n"的报错，它是找不到n的，因为static进行了文件隔离，你是没办法访问a.c定义的静态全局变量的，当然你用 #include "a.c",那就不一样了。

以上我们就可以得出静态全局变量的特点：
（1）静态全局变量不能被其它文件所用(全局变量可以);
（2）其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);

1.3 静态函数：准确的说，静态函数跟静态全局变量的作用类似：

```
//file a.c
#include <stdio.h>
 
 
void fn()
{
	printf("this is non-static func in a");
}
 
 
//file b.c
#include <stdio.h>
 
 
extern void fn();  //我们用extern声明其他文件的fn(),供本文件使用。
 
 
void main()
{
	fn();
}
```

可以正常输出：this is non-static func in a。
当给void fn()加上static的关键字之后呢？ undefined reference to "fn".

所以，静态函数的好处跟静态全局变量的好处就类似了：
1.静态函数不能被其它文件所用;
2.其它文件中可以定义相同名字的函数，不会发生冲突;

上面一共说了三种用法，为什么说准确来说是两种呢？
1.一种是修饰变量，一种是修饰函数，所以说是两种（这种解释不多）。
2.静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。


2. C++ 语言的 static 关键字有二种用途：
   当然以上的几种，也可以用在c++中。还有额外的两种用法：

2.1 静态数据成员：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。

```c++
#include<iostream>
 
 
using namespace std;
 
 
class Rectangle
{
private:
	int m_w,m_h;
	static int s_sum;
	
public:
	Rectangle(int w,int h)
	{
		this->m_w = w;
		this->m_h = h;
		s_sum += (this->m_w * this->m_h);
	}
 
 
	void GetSum()
	{
		cout<<"sum = "<<s_sum<<endl;
	}
 
 
};
 
int Rectangle::s_sum = 0;  //初始化
 
int main()
{
	cout<<"sizeof(Rectangle)="<<sizeof(Rectangle)<<endl;
	Rectangle *rect1 = new Rectangle(3,4);
	rect1->GetSum();
	cout<<"sizeof(rect1)="<<sizeof(*rect1)<<endl;
	Rectangle rect2(2,3);
	rect2.GetSum();
	cout<<"sizeof(rect2)="<<sizeof(rect2)<<endl;
	
	system("pause");
	return 0;
}
```

输出

```
sizeof Rectangle=8
sum=12
sizeof rect1=8
sum=18
sizeof rect2=8
```

由图可知：sizeof(Rectangle)=8bytes=sizeof(m_w)+sizeof(m_h)。也就是说 static 并不占用Rectangle的内存空间。
那么static在哪里分配内存的呢？是的，全局数据区(静态区)。
再看看GetSum()，第一次12=3*4，第二次18=12+2*3。由此可得，static只会被初始化一次，于实例无关。

对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。

也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。

2.2 静态成员函数：用于修饰 class 的成员函数。
我们对上面的例子稍加改动：

```c++
#include<iostream>
using namespace std;
 
class Rectangle
{
private:
	int m_w,m_h;
	static int s_sum;
	
public:
	Rectangle(int w,int h)
	{
		this->m_w = w;
		this->m_h = h;
		s_sum += (this->m_w * this->m_h);
	}
 
 
	static void GetSum()  //这里加上static
	{
		cout<<"sum = "<<s_sum<<endl;
	}
 
 
};
 
 
int Rectangle::s_sum = 0;  //初始化
 
int main()
{
	cout<<"sizeof(Rectangle)="<<sizeof(Rectangle)<<endl;
	Rectangle *rect1 = new Rectangle(3,4);
	rect1->GetSum();
	cout<<"sizeof(rect1)="<<sizeof(*rect1)<<endl;
	Rectangle rect2(2,3);
	rect2.GetSum();  //可以用对象名.函数名访问
	cout<<"sizeof(rect2)="<<sizeof(rect2)<<endl;
	Rectangle::GetSum();  //也可以可以用类名::函数名访问
 
 
	system("pause");
	return 0;
}
```

上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。
那么静态成员函数有特点呢？
1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;
2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;
3.静态成员函数不能访问非静态成员函数和非静态数据成员;
4.调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)

前三点其实是一点：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态，有点晕吗？没关系，我给你个解释，
因为静态是属于类的，它是不知道你创建了10个还是100个对象，所以它对你对象的函数或者数据是一无所知的，所以它没办法调用，而反过来，你创建的对象是对类一清二楚的(不然你怎么从它那里实例化呢)，所以你是可以调用类函数和类成员的，就像不管GetSum是不是static，都可以调用static的s_sum一样。

3. Q&A

（7）静态成员函数与非静态成员函数的区别
答：根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。
（8）为什么要用得静态成员变量和静态成员函数
答：为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享
（9）静态成员的作用、优点
答：静态成员函数主要为了调用方便，不需要生成对象就能调用。



## 第8章 IO库

**前面章节已经在用的IO库设施**

- **istream**：输入流类型，提供输入操作。
- **ostream**：输出流类型，提供输出操作
- **cin**：一个`istream`对象，从标准输入读取数据。
- **cout**：一个`ostream`对象，向标准输出写入数据。
- **cerr**：一个`ostream`对象，向标准错误写入消息。
- **>>运算符**：用来从一个`istream`对象中读取输入数据。
- **<<运算符**：用来向一个`ostream`对象中写入输出数据。
- **getline函数**：从一个给定的`istream`对象中读取一行数据，存入到一个给定的`string`对象中。

### IO类

#### 标准库定义的IO类型

- `iostream`头文件：从标准流中读写数据，`istream`、`ostream`等。
- `fstream`头文件：从文件中读写数据，`ifstream`、`ofstream`等。
- `sstream`头文件：从字符串中读写数据，`istringstream`、`ostringstream`

#### IO对象不可复制或赋值

- 1.IO对象不能存在容器里.
- 2.形参和返回类型也不能是流类型。
- 3.形参和返回类型一般是流的**引用**。
- 4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。

#### 条件状态

| 状态                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `strm:iostate`      | 是一种机器无关的**类型**，提供了表达条件状态的完整功能       |
| `strm:badbit`       | 用来指出流已经崩溃                                           |
| `strm:failbit`      | 用来指出一个IO操作失败了                                     |
| `strm:eofbit`       | 用来指出流到达了文件结束                                     |
| `strm:goodbit`      | 用来指出流未处于错误状态，此值保证为零                       |
| `s.eof()`           | 若流`s`的`eofbit`置位，则返回`true`                          |
| `s.fail()`          | 若流`s`的`failbit`置位，则返回`true`                         |
| `s.bad()`           | 若流`s`的`badbit`置位，则返回`true`                          |
| `s.good()`          | 若流`s`处于有效状态，则返回`true`                            |
| `s.clear()`         | 将流`s`中所有条件状态位复位，将流的状态设置成有效，返回`void` |
| `s.clear(flags)`    | 将流`s`中指定的条件状态位复位，返回`void`                    |
| `s.setstate(flags)` | 根据给定的标志位，将流`s`中对应的条件状态位置位，返回`void`  |
| `s.rdstate()`       | 返回流`s`的当前条件状态，返回值类型为`strm::iostate`         |

上表中，`strm`是一种IO类型，（如`istream`）， `s`是一个流对象。

### 管理输出缓冲

- 每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。
- 刷新缓冲区，可以使用如下IO操纵符：
  - `endl`：输出一个换行符并刷新缓冲区。
  - `flush`：刷新流，单不添加任何字符。
  - `ends`：在缓冲区插入空字符`null`，然后刷新。
  - `unitbuf`：告诉流接下来每次操作之后都要进行一次`flush`操作。
  - `nounitbuf`：回到正常的缓冲方式。

### 文件输入输出

- 头文件`fstream`定义了三个类型来支持文件IO：
  - `ifstream`从一个给定文件读取数据。
  - `ofstream`向一个给定文件写入数据。
  - `fstream`可以读写给定文件。
- **文件流**：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。

#### fstream特有的操作

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `fstream fstrm;`          | 创建一个未绑定的文件流。                                     |
| `fstream fstrm(s);`       | 创建一个文件流，并打开名为`s`的文件，`s`可以是`string`也可以是`char`指针 |
| `fstream fstrm(s, mode);` | 与前一个构造函数类似，但按指定`mode`打开文件                 |
| `fstrm.open(s)`           | 打开名为`s`的文件，并和`fstrm`绑定                           |
| `fstrm.close()`           | 关闭和`fstrm`绑定的文件                                      |
| `fstrm.is_open()`         | 返回一个`bool`值，指出与`fstrm`关联的文件是否成功打开且尚未关闭 |

上表中，`fstream`是头文件`fstream`中定义的一个类型，`fstrm`是一个文件流对象。

#### 文件模式

| 文件模式 | 解释                         |
| -------- | ---------------------------- |
| `in`     | 以读的方式打开               |
| `out`    | 以写的方式打开               |
| `app`    | 每次写操作前均定位到文件末尾 |
| `ate`    | 打开文件后立即定位到文件末尾 |
| `trunc`  | 截断文件                     |
| `binary` | 以二进制方式进行IO操作。     |

### string流

- 头文件`sstream`定义了三个类型来支持内存IO：
  - `istringstream`从`string`读取数据。
  - `ostringstream`向`string`写入数据。
  - `stringstream`可以读写给定`string`。

#### stringstream特有的操作

| 操作              | 解释                               |
| ----------------- | ---------------------------------- |
| `sstream strm`    | 定义一个未绑定的`stringstream`对象 |
| `sstream strm(s)` | 用`s`初始化对象                    |
| `strm.str()`      | 返回`strm`所保存的`string`的拷贝   |
| `strm.str(s)`     | 将`s`拷贝到`strm`中，返回`void`    |

上表中`sstream`是头文件`sstream`中任意一个类型。`s`是一个`string`。



## 5 文件操作



程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过**文件可以将数据持久化**

C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==



文件类型分为两种：

1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中
2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们



操作文件的三大类:

1. ofstream：写操作
2. ifstream： 读操作
3. fstream ： 读写操作



### 5.1文本文件

#### 5.1.1写文件

   写文件步骤如下：

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ofstream ofs;

3. 打开文件

   ofs.open("文件路径",打开方式);

4. 写数据

   ofs << "写入的数据";

5. 关闭文件

   ofs.close();

   

文件打开方式：

| 打开方式    | 解释                       |
| ----------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始位置：文件尾           |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在先删除，再创建 |
| ios::binary | 二进制方式                 |

**注意：** 文件打开方式可以配合使用，利用|操作符

**例如：**用二进制方式写文件 `ios::binary |  ios:: out`





**示例：**

```C++
#include <fstream>

void test01()
{
	ofstream ofs;
	ofs.open("test.txt", ios::out);

	ofs << "姓名：张三" << endl;
	ofs << "性别：男" << endl;
	ofs << "年龄：18" << endl;

	ofs.close();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 文件操作必须包含头文件 fstream
* 读文件可以利用 ofstream  ，或者fstream类
* 打开文件时候需要指定操作文件的路径，以及打开方式
* 利用<<可以向文件中写数据
* 操作完毕，要关闭文件

















#### 5.1.2读文件



读文件与写文件步骤相似，但是读取方式相对于比较多



读文件步骤如下：

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ifstream ifs;

3. 打开文件并判断文件是否打开成功

   ifs.open("文件路径",打开方式);

4. 读数据

   四种方式读取

5. 关闭文件

   ifs.close();



**示例：**

```C++
#include <fstream>
#include <string>
void test01()
{
	ifstream ifs;
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//第一种方式
	//char buf[1024] = { 0 };
	//while (ifs >> buf)
	//{
	//	cout << buf << endl;
	//}

	//第二种
	//char buf[1024] = { 0 };
	//while (ifs.getline(buf,sizeof(buf)))
	//{
	//	cout << buf << endl;
	//}

	//第三种
	//string buf;
	//while (getline(ifs, buf))
	//{
	//	cout << buf << endl;
	//}

	char c;
	while ((c = ifs.get()) != EOF)
	{
		cout << c;
	}

	ifs.close();


}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 读文件可以利用 ifstream  ，或者fstream类
- 利用is_open函数可以判断文件是否打开成功
- close 关闭文件 















### 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为 ==ios::binary==



#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型 ：`ostream& write(const char * buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数



**示例：**

```C++
#include <fstream>
#include <string>

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件  写文件
void test01()
{
	//1、包含头文件

	//2、创建输出流对象
	ofstream ofs("person.txt", ios::out | ios::binary);
	
	//3、打开文件
	//ofs.open("person.txt", ios::out | ios::binary);

	Person p = {"张三"  , 18};

	//4、写文件
	ofs.write((const char *)&p, sizeof(p));

	//5、关闭文件
	ofs.close();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 文件输出流对象 可以通过write函数，以二进制方式写数据











#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`istream& read(char *buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数

示例：

```C++
#include <fstream>
#include <string>

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

void test01()
{
	ifstream ifs("person.txt", ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
	}

	Person p;
	ifs.read((char *)&p, sizeof(p));

	cout << "姓名： " << p.m_Name << " 年龄： " << p.m_Age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



- 文件输入流对象 可以通过read函数，以二进制方式读数据



## 第9章 顺序容器

### 顺序容器概述

- **顺序容器**（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

**顺序容器类型**

| 容器类型       | 介绍                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快。 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或者删除元素。       |
| `string`       | 与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |

- 除了固定大小的`array`外，其他容器都提供高效、灵活的内存管理。
- string、vector支持随机访问，但是在中间位置添加或者删除元素非常耗时
- list、forward_list设计的目的是令容器任何位置的添加和删除操作都很快速，但不支持随机访问，只能遍历
- deque支持快速随机访问，在中间位置添加或删除很耗时，但在两端很快
- `forward_list`和`array`是新C++标准增加的类型。
- 通常使用`vector`是最好的选择，除非你有很好的理由选择其他容器。
- 新标准库的容器比旧版的快得多。

### 容器操作

#### 类型

| 操作              | 解释                                               |
| ----------------- | -------------------------------------------------- |
| `iterator`        | 此容器类型的迭代器类型                             |
| `const_iterator`  | 可以读取元素但不能修改元素的迭代器类型             |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离       |
| `value_type`      | 元素类型                                           |
| `reference`       | 元素的左值类型；和`value_type &`含义相同           |
| `const_reference` | 元素的`const`左值类型，即`const value_type &`      |

#### 构造函数

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `C c;`                    | 默认构造函数，构造空容器                                     |
| `C c1(c2);`或`C c1 = c2;` | 构造`c2`的拷贝`c1`                                           |
| `C c(b, e)`               | 构造`c`，将迭代器`b`和`e`指定范围内的所有元素拷贝到`c`       |
| `C c(a, b, c...)`         | 列表初始化`c`                                                |
| `C c(n)`                  | 只支持顺序容器，且不包括`array`，包含`n`个元素，这些元素进行了值初始化 |
| `C c(n, t)`               | 包含`n`个初始值为`t`的元素                                   |

- 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
- `array`具有固定大小。
- 和其他容器不同，默认构造的`array`是非空的。
- 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
- 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

#### 赋值和`swap`

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c1 = c2;`          | 将`c1`中的元素替换成`c2`中的元素                             |
| `c1 = {a, b, c...}` | 将`c1`中的元素替换成列表中的元素（不适用于`array`）          |
| `c1.swap(c2)`       | 交换`c1`和`c2`的元素                                         |
| `swap(c1, c2)`      | 等价于`c1.swap(c2)`                                          |
| `c.assign(b, e)`    | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)`      | 将`c`中的元素替换成初始化列表`il`中的元素                    |
| `c.assign(n, r)`    | 将`c`中的元素替换为`n`个值是`t`的元素                        |

- 使用非成员版本的`swap`是一个好习惯。
- `assign`操作不适用于关联容器和`array`

#### 大小

| 操作           | 解释                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目（不支持`forward_list`）        |
| `c.max_size()` | `c`中可保存的最大元素数目                      |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |

#### 添加元素

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `c.push_back(t)`        | 在`c`尾部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_back(args)`  | 同上                                                         |
| `c.push_front(t)`       | 在`c`头部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_front(args)` | 同上                                                         |
| `c.insert(p, t)`        | 在迭代器`p`指向的元素之前创建一个值是`t`的元素，返回指向新元素的迭代器 |
| `c.emplace(p, args)`    | 同上                                                         |
| `c.insert(p, n, t)`     | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素，返回指向第一个新元素的迭代器；如果`n`是0，则返回`p` |
| `c.insert(p, b, e)`     | 将迭代器`b`和`e`范围内的元素，插入到`p`指向的元素之前；如果范围为空，则返回`p` |
| `c.insert(p, il)`       | `il`是一个花括号包围中的元素值列表，将其插入到`p`指向的元素之前；如果`il`是空，则返回`p` |

- 因为这些操作会改变大小，因此不适用于`array`。
- `forward_list`有自己专有版本的`insert`和`emplace`。
- `forward_list`不支持`push_back`和`emplace_back`。
- 当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。
- `emplace`开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。
- 传递给`emplace`的参数必须和元素类型的构造函数相匹配。

#### 访问元素

| 操作        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义             |
| `c.front()` | 返回`c`中头元素的引用。若`c`为空，函数行为未定义             |
| `c[n]`      | 返回`c`中下标是`n`的元素的引用，`n`时候一个无符号证书。若`n>=c.size()`，则函数行为未定义 |
| `c.at(n)`   | 返回下标为`n`的元素引用。如果下标越界，则抛出`out_of_range`异常 |

- 访问成员函数返回的是引用。
- `at`和下标操作只适用于`string`、`vector`、`deque`、`array`。
- `back`不适用于`forward_list`。
- 如果希望下标是合法的，可以使用`at`函数。

#### 删除元素

| 操作            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| `c.pop_back()`  | 删除`c`中尾元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()` | 删除`c`中首元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)`    | 删除迭代器`p`指向的元素，返回一个指向被删除元素之后的元素的迭代器，若`p`本身是尾后迭代器，则函数行为未定义 |
| `c.erase(b, e)` | 删除迭代器`b`和`e`范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若`e`本身就是尾后迭代器，则返回尾后迭代器 |
| `c.clear()`     | 删除`c`中所有元素，返回`void`                                |

- 会改变容器大小，不适用于`array`。
- `forward_list`有特殊版本的`erase`
- `forward_list`不支持`pop_back`
- `vector`和`string`不支持`pop_front`

#### 特殊的forwad_list操作

- 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。
- `forward_list`定义了`before_begin`，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。

| 操作                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `lst.before_begin()`        | 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 |
| `lst.cbefore_begin()`       | 同上，但是返回的是常量迭代器。                               |
| `lst.insert_after(p, t)`    | 在迭代器`p`之后插入元素。`t`是一个对象                       |
| `lst.insert_after(p, n, t)` | 在迭代器`p`之后插入元素。`t`是一个对象，`n`是数量。若`n`是0则函数行为未定义 |
| `lst.insert_after(p, b, e)` | 在迭代器`p`之后插入元素。由迭代器`b`和`e`指定范围。          |
| `lst.insert_after(p, il)`   | 在迭代器`p`之后插入元素。由`il`指定初始化列表。              |
| `emplace_after(p, args)`    | 使用`args`在`p`之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(p)`        | 删除`p`指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(b, e)`     | 类似上面，删除对象换成从`b`到`e`指定的范围。                 |

#### 改变容器大小

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `c.resize(n)`    | 调整`c`的大小为`n`个元素，若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n, t)` | 调整`c`的大小为`n`个元素，任何新添加的元素都初始化为值`t`    |

#### 获取迭代器

| 操作                     | 解释                                        |
| ------------------------ | ------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回`const_iterator`                        |

- 以`c`开头的版本是C++11新标准引入的
- 当不需要写访问时，应该使用`cbegin`和`cend`。

#### 反向容器的额外成员

| 操作                       | 解释                                        |
| -------------------------- | ------------------------------------------- |
| `reverse_iterator`         | 按逆序寻址元素的迭代器                      |
| `const_reverse_iterator`   | 不能修改元素的逆序迭代器                    |
| `c.rbegin()`, `c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()` | 返回`const_reverse_iterator`                |

- 不支持`forward_list`

#### 迭代器

- 迭代器范围：`begin`到`end`，即第一个元素到最后一个元素的后面一个位置。
- 左闭合区间：`[begin, end)`
- 左闭合范围蕴含的编程设定：
  - 如果`begin`和`end`相等，则范围为空。
  - 如果二者不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。
  - 可以对`begin`递增若干次，使得`begin == end`。

#### 容器操作可能使迭代器失效

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器、指针和引用依然有效。
- 在从一个容器中删除元素后：
  - 对于`list`和`forward_list`，指向容器其他位置的迭代器、引用和指针仍然有效。
  - 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除`deque`的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是`deque`的头元素，这些也不会受影响。
  - 对于`vector`和`string`，指向被删元素之前的迭代器、引用、指针仍然有效。
  - 注意：当我们删除元素时，尾后迭代器总是会失效。
  - 注意：使用失效的迭代器、指针、引用是严重的运行时错误！
  - 建议：将要求迭代器必须保持有效的程序片段最小化。
  - 建议：不要保存`end`返回的迭代器。

#### 容器内元素的类型约束

- 元素类型必须支持赋值运算；
- 元素类型的对象必须可以复制。
- 除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。

### vector对象是如何增长的

`vector`和`string`在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。

#### 管理容量的成员函数

| 操作                | 解释                                          |
| ------------------- | --------------------------------------------- |
| `c.shrink_to_fit()` | 将`capacity()`减少到和`size()`相同大小        |
| `c.capacity()`      | 不重新分配内存空间的话，`c`可以保存多少个元素 |
| `c.reverse(n)`      | 分配至少能容纳`n`个元素的内存空间             |

- `shrink_to_fit`只适用于`vector`、`string`和`deque`
- `capacity`和`reverse`只适用于`vector`和`string`。

### 额外的string操作

#### 构造string的其他方法

| 操作                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `string s(cp, n)`          | `s`是`cp`指向的数组中前`n`个字符的拷贝，此数组               |
| `string s(s2, pos2)`       | `s`是`string s2`从下标`pos2`开始的字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。 |
| `string s(s2, pos2, len2)` | `s`是`string s2`从下标`pos2`开始的`len2`个字符的拷贝。       |

- `n`,`len2`,`pos2`都是无符号值。

#### substr操作

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.substr(pos, n)` | 返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝。`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即拷贝从`pos`开始的所有字符。 |

#### 改变string的其他方法

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s.insert(pos, args)`    | 在`pos`之前插入`args`指定的字符。`pos`可以使是下标或者迭代器。接受下标的版本返回指向`s`的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 |
| `s.erase(pos, len)`      | 删除从`pos`开始的`len`个字符，如果`len`被省略，则删除后面所有字符，返回指向`s`的引用。 |
| `s.assign(args)`         | 将`s`中的字符替换成`args`指定的字符。返回一个指向`s`的引用。 |
| `s.append(args)`         | 将`args`指定的字符追加到`s`，返回一个指向`s`的引用。         |
| `s.replace(range, args)` | 删除`s`中范围`range`中的字符，替换成`args`指定的字符。返回一个指向`s`的引用。 |

#### string搜索操作

- `string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 每个搜索操作都返回一个`string::size_type`值，表示匹配发生位置的下标。如果搜索失败则返回一个名为`string::npos`的`static`成员（类型是`string::size_type`，初始化值是-1，也就是`string`最大的可能大小）。

| 搜索操作                    | 解释                                              |
| --------------------------- | ------------------------------------------------- |
| `s.find(args)`              | 查找`s`中`args`第一次出现的位置                   |
| `s.rfind(args)`             | 查找`s`中`args`最后一次出现的位置                 |
| `s.find_first_of(args)`     | 在`s`中查找`args`中任何一个字符第一次出现的位置   |
| `s.find_last_of(args)`      | 在`s`中查找`args`中任何一个字符最后一次出现的位置 |
| `s.find_first_not_of(args)` | 在`s`中查找第一个不在`args`中的字符               |
| `s.find_first_not_of(args)` | 在`s`中查找最后一个不在`args`中的字符             |

args必须是一下的形式之一：

| `args`形式   | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| `c, pos`     | 从`s`中位置`pos`开始查找字符`c`。`pos`默认是0                |
| `s2, pos`    | 从`s`中位置`pos`开始查找字符串`s`。`pos`默认是0              |
| `cp, pos`    | 从`s`中位置`pos`开始查找指针`cp`指向的以空字符结尾的C风格字符串。`pos`默认是0 |
| `cp, pos, n` | 从`s`中位置`pos`开始查找指针`cp`指向的前`n`个字符。`pos`和`n`无默认值。 |

#### s.compare的几种参数形式

逻辑类似于C标准库的`strcmp`函数，根据`s`是等于、大于还是小于参数指定的字符串，`s.compare`返回0、正数或负数。

| 参数形式                 | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s2`                     | 比较`s`和`s2`                                                |
| `pos1, n1, s2`           | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `pos1, n1, s2, pos2, n2` | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `cp`                     | 比较`s`和`cp`指向的以空字符结尾的字符数组                    |
| `pos1, n1, cp`           | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp, n2`       | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的地址开始`n2`个字符 |

#### string和数值转换

| 转换              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `to_string(val)`  | 一组重载函数，返回数值`val`的`string`表示。`val`可以使任何算术类型。对每个浮点类型和`int`或更大的整型，都有相应版本的`to_string()`。和往常一样，小整型会被提升。 |
| `stoi(s, p, b)`   | 返回`s`起始子串（表示整数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0，`b`是转换所用的基数。返回`int` |
| `stol(s, p, b)`   | 返回`long`                                                   |
| `stoul(s, p, b)`  | 返回`unsigned long`                                          |
| `stoll(s, p, b)`  | 返回`long long`                                              |
| `stoull(s, p, b)` | 返回`unsigned long long`                                     |
| `stof(s, p)`      | 返回`s`起始子串（表示浮点数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0。返回`float` |
| `stod(s, p)`      | 返回`double`                                                 |
| `stold(s, p)`     | 返回`long double`                                            |

### 容器适配器（adapter）

- 适配器是使一事物的行为类似于另一事物的行为的一种机制，例如`stack`可以使任何一种顺序容器以栈的方式工作。
- 初始化 `deque<int> deq; stack<int> stk(deq);` 从`deq`拷贝元素到`stk`。
- 创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： `stack<string, vector<string> > str_stk;`。

#### 适配器的通用操作和类型

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `size_type`      | 一种类型，须以保存当前类型的最大对象的大小                   |
| `value_type`     | 元素类型                                                     |
| `container_type` | 实现适配器的底层容器类型                                     |
| `A a;`           | 创建一个名为`a`的空适配器                                    |
| `A a(c)`         | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符       | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、 `<=`、`>`、`>=`这些运算符返回底层容器的比较结果 |
| `a.empty()`      | 若`a`包含任何元素，返回`false`;否则返回`true`                |
| `a.size()`       | 返回`a`中的元素数目                                          |
| `swap(a, b)`     | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |
| `a.swap(b)`      | 同上                                                         |

#### stack

| 操作              | 解释                                                     |
| ----------------- | -------------------------------------------------------- |
| `s.pop()`         | 删除栈顶元素，不返回。                                   |
| `s.push(item)`    | 创建一个新元素，压入栈顶，该元素通过拷贝或移动`item`而来 |
| `s.emplace(args)` | 同上，但元素由`args`来构造。                             |
| `s.top()`         | 返回栈顶元素，不删除。                                   |

- 定义在`stack`头文件中。
- `stack`默认基于`deque`实现，也可以在`list`或`vector`之上实现。

#### queue和priority_queue

| 操作              | 解释                                      |
| ----------------- | ----------------------------------------- |
| `q.pop()`         | 删除队首元素，但不返回。                  |
| `q.front()`       | 返回队首元素的值，不删除。                |
| `q.back()`        | 返回队尾元素的值，不删除。只适用于`queue` |
| `q.top()`         | 返回具有最高优先级的元素值，不删除。      |
| `q.push(item)`    | 在队尾压入一个新元素。                    |
| `q.emplace(args)` |                                           |

- 定义在`queue`头文件中。
- `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。
- `queue`可以在`list`或`vector`之上实现，`priority_queue`也可以用`deque`实现。



## 第10章 泛型算法

### 泛型算法

- 因为它们实现共同的操作，所以称之为“**算法**”；而“**泛型**”、指的是它们可以操作在多种容器类型上。
- 泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。
- 头文件： `#include <algorithm>`或者 `#include <numeric>`(算数相关)
- 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。
- 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。

#### find

- `vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);`
- 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。

### 初识泛型算法

- 标准库提供了超过100个算法，但这些算法有一致的结构。
- 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

#### 只读算法

- 只读取范围中的元素，不改变元素。
- 如 `find`和 `accumulate`（在`numeric`中定义，求和）。
- `find_first_of`，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的`end`迭代器。
- 通常最好使用`cbegin`和`cend`。
- `equal`：确定两个序列是否保存相同的值。

#### 写容器元素的算法

- 一些算法将新值赋予序列中的元素。
- 算法不检查写操作。
- `fill`： `fill(vec.begin(), vec.end(), 0);` 将每个元素重置为0
- `fill_n`： `fill_n(vec.begin(), 10, 0);`
- 插入迭代器`back_inserter`：
  - 用来确保算法有足够的空间存储数据。
  - `#include <iterator>`
  - `back_inserter(vec)`
- 拷贝算法`copy`：
- 输入：前两个参数指定输入范围，第三个指向目标序列。
- `copy (ilst.begin(), ilst.end(), back_inserter(ivec));`
- `copy`时必须保证目标目的序列至少要包含与输入序列一样多的元素。

#### 重排容器元素的算法

- 这些算法会重排容器中元素的顺序。
- 排序算法`sort`：
  - 接受两个迭代器，表示要排序的元素范围。
- 消除重复`unique`：
  - 之前要先调用`sort`
  - 返回的迭代器指向最后一个不重复元素之后的位置。
  - 顺序会变，重复的元素被“删除”。
  - 并没有真正删除，真正删除必须使用容器操作。

### 定制操作

#### 向算法传递函数：

- 谓词（`predicate`）：
  - 是一个**可调用的表达式**，返回结果是一个能用作条件的值
  - 一元谓词：接受一个参数
  - 二元谓词：接受两个参数

- 例子：
  - `stable_sort`：
    - 保留相等元素的原始相对位置。
    - `stable_sort(words.begin(), words.end(), isShorter);`

#### lambda表达式

- 有时可能希望操作可以接受更多的参数。
- `lambda`表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。
- 形式：`[capture list](parameter list) -> return type {function body}`。
  - 其中`capture list`捕获列表是一个`lambda`所在函数定义的局部变量的列表（通常为空）。不可忽略。
  - `return type`是返回类型。可忽略。
  - `parameter`是参数列表。可忽略。
  - `function body`是函数体。不可忽略。
  - `auto f = [] {return 42;}`

- 例子：
  - `find_if`:
    - 接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。
    - `auto wc = find_if(words.begin(), words.end(), [sz](const string &a){return a.size() >= sz;});`
  - `for_each`：
    - 接受一个可调用对象，并对序列中每个元素调用此对象。
    - `for_each(wc, words.end(), [](const string &s){cout << s << " ";})`

#### lambda捕获和返回

- 定义`lambda`时会生成一个新的类类型和该类型的一个对象。
- 默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员，在`lambda`对象创建时被初始化。
- **值捕获**：前提是变量可以拷贝，`size_t v1 = 42; auto f = [v1] {return v1;};`。
- **引用捕获**：必须保证在`lambda`执行时，变量是存在的，`auto f2 = [&v1] {return v1;};`
- 尽量减少捕获的数据量，尽可能避免捕获指针或引用。
- **隐式捕获**：让编译器推断捕获列表，在捕获列表中写一个`&`（引用方式）或`=`（值方式）。`auto f3 = [=] {return v1;}`

**lambda捕获列表**：

| 捕获列表               | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。`lambda`不能使用所在函数中的变量。一个`lambda`只有在捕获变量后才能使用它们。 |
| `[names]`              | `names`是一个逗号分隔的名字列表，这些名字都是在`lambda`所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了`&`，则采用引用捕获方式。 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式。`lambda`体中所使用的来自所在函数的实体都采用引用方式使用。 |
| `[=]`                  | 隐式捕获列表，采用值捕获方式。                               |
| `[&, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。`identifier_list`中的名字前面不能使用`&` |
| `[=, identifier_list]` | `identifier_list`中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。`identifier_list`中的名字不能包括`this`，且前面必须使用`&` |

#### 参数绑定

- `lambda`表达式更适合在一两个地方使用的简单操作。
- 如果是很多地方使用相同的操作，还是需要定义函数。
- 函数如何包装成一元谓词？使用参数绑定。
- 标准库`bind`函数：
  - 定义在头文件`functional`中，可以看做为一个通用的函数适配器。
  - `auto newCallable = bind(callable, arg_list);`
  - 我们再调用`newCallable`的时候，`newCallable`会调用`callable`并传递给它`arg_list`中的参数。
  - `_n`代表第n个位置的参数。定义在`placeholders`的命名空间中。`using std::placeholder::_1;`
  - `auto g = bind(f, a, b, _2, c, _1);`，调用`g(_1, _2)`实际上调用`f(a, b, _2, c, _1)`
  - 非占位符的参数要使用引用传参，必须使用标准库`ref`函数或者`cref`函数。

### 再探迭代器

#### 插入迭代器

- 插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
- 三种类型：
  - `back_inserter`：创建一个使用`push_back`的迭代器。
  - `front_inserter`创建一个使用`push_front`的迭代器。
  - `inserter`创建一个使用`insert`的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。

**插入迭代器操作**：

| 操作              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `it=t`            | 在`it`指定的当前位置插入值`t`。假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`、`c.insert(t, p)`，其中`p`是传递给`inserter`的迭代器位置 |
| `*it, ++it, it++` | 这些操作虽然存在，但不会对`it`做任何事情，每个操作都返回`it` |

#### iostream迭代器

- 迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。
- 通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。

**istream_iterator的操作**：

| 操作                          | 解释                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T> in(is);` | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end;`    | 读取类型是`T`的值的`istream_iterator`迭代器，表示尾后位置    |
| `in1 == in2`                  | `in1`和`in2`必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。 |
| `in1 != in2`                  | 类似上条                                                     |
| `*in`                         | 返回从流中读取的值                                           |
| `in->mem`                     | 与`*(in).mem`含义相同                                        |
| `++in, in++`                  | 使用元素类型所定义的`>>`运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 |

**ostream_iterator的操作**：

| 操作                              | 解释                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os);`    | `out`将类型为`T`的值写到输出流`os`中                         |
| `ostream_iterator<T> out(os, d);` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组。 |
| `out = val`                       | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。`val`的类型必须和`out`可写的类型兼容。 |
| `*out, ++out, out++`              | 这些运算符是存在的，但不对`out`做任何事情。每个运算符都返回`out`。 |

### 反向迭代器

- 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。
- 对于反向迭代器，递增和递减的操作含义会颠倒。
- 实现向后遍历，配合`rbegin`和`rend`。

### 泛型算法结构

#### 5类迭代器

| 迭代器类别     | 解释                                 | 支持的操作                                                   |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| 输入迭代器     | 只读，不写；单遍扫描，只能递增       | `==`,`!=`,`++`,`*`,`->`                                      |
| 输出迭代器     | 只写，不读；单遍扫描，只能递增       | `++`,`*`                                                     |
| 前向迭代器     | 可读写；多遍扫描，只能递增           | `==`,`!=`,`++`,`*`,`->`                                      |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         | `==`,`!=`,`++`,`--`,`*`,`->`                                 |
| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 | `==`,`!=`,`<`,`<=`,`>`,`>=`,`++`,`--`,`+`,`+=`,`-`,`-=`,`*`,`->`,`iter[n]`==`*(iter[n])` |

#### 算法的形参模式

- `alg(beg, end, other args);`
- `alg(beg, end, dest, other args);`
- `alg(beg, end, beg2, other args);`
- `alg(beg, end, beg2, end2, other args);`

其中，`alg`是算法名称，`beg`和`end`表示算法所操作的输入范围。`dest`、`beg2`、`end2`都是迭代器参数，是否使用要依赖于执行的操作。

#### 算法命名规范

- 一些算法使用重载形式传递一个谓词。
- 接受一个元素值的算法通常有一个**不同名**的版本：加`_if`，接受一个谓词代替元素值。
- 区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加`_copy`。

### 特定容器算法

- 对于`list`和`forward_list`，优先使用成员函数版本的算法而不是通用算法。

**list和forward_list成员函数版本的算法**：

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `lst.merge(lst2)`       | 将来自`lst2`的元素合并入`lst`，二者都必须是有序的，元素将从`lst2`中删除。 |
| `lst.merge(lst2, comp)` | 同上，给定比较操作。                                         |
| `lst.remove(val)`       | 调用`erase`删除掉与给定值相等(==)的每个元素                  |
| `lst.remove_if(pred)`   | 调用`erase`删除掉令一元谓词为真的每个元素                    |
| `lst.reverse()`         | 反转`lst`中元素的顺序                                        |
| `lst.sort()`            | 使用`<`排序元素                                              |
| `lst.sort(comp)`        | 使用给定比较操作排序元素                                     |
| `lst.unique()`          | 调用`erase`删除同一个值的连续拷贝。使用`==`。                |
| `lst.unique(pred)`      | 调用`erase`删除同一个值的连续拷贝。使用给定的二元谓词。      |

- 上面的操作都返回`void`

**list和forward_list的splice成员函数版本的参数**：

| 参数              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `(p, lst2)`       | `p`是一个指向`lst`中元素的迭代器，或者一个指向`flst`首前位置的迭代器。函数将`lst2`中的所有元素移动到`lst`中`p`之前的位置或是`flst`中`p`之后的位置。将元素从`lst2`中删除。`lst2`的类型必须和`lst`相同，而且不能是同一个链表。 |
| `(p, lst2, p2)`   | 同上，`p2`是一个指向`lst2`中位置的有效的迭代器，将`p2`指向的元素移动到`lst`中，或将`p2`之后的元素移动到`flst`中。`lst2`可以是于`lst`或`flst`相同的链表。 |
| `(p, lst2, b, e)` | `b`和`e`表示`lst2`中的合法范围。将给定范围中的元素从`lst2`移动到`lst`或`first`中。`lst2`与`lst`可以使相同的链表，但`p`不能指向给定范围中的元素。 |

- 使用`lst.splice(args)`或`flst.splice_after(args)`

## 第12章 动态内存

- 对象的生命周期：
  - 全局对象在程序启动时分配，结束时销毁。
  - 局部对象在进入程序块时创建，离开块时销毁。
  - 局部`static`对象在第一次使用前分配，在程序结束时销毁。
  - 动态分配对象：只能显式地被释放。

- 对象的内存位置：
  - **静态内存**用来保存局部`static`对象、类`static`对象、定义在任何函数之外的变量。
  - **栈内存**用来保存定义在函数内的非`static`对象。
  - **堆内存**，又称自由空间，用来存储**动态分配**的对象。

### 动态内存与智能指针

- 动态内存管理：
  - `new`：在动态内存中为对象分配空间并返回一个指向该对象的指针。
  - `delete`：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
- 智能指针：
  - 管理动态对象。
  - 行为类似常规指针。
  - 负责自动释放所指向的对象。
  - 智能指针也是模板。

#### shared_ptr类

**shared_ptr和unique_ptr都支持的操作**：

| 操作                                   | 解释                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `shared_ptr<T> sp`  `unique_ptr<T> up` | 空智能指针，可以指向类型是`T`的对象                          |
| `p`                                    | 将`p`用作一个条件判断，若`p`指向一个对象，则为`true`         |
| `*p`                                   | 解引用`p`，获得它指向的对象。                                |
| `p->mem`                               | 等价于`(*p).mem`                                             |
| `p.get()`                              | 返回`p`中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。 |
| `swap(p, q)` `p.swap(q)`               | 交换`p`和`q`中的指针                                         |

**shared_ptr独有的操作**：

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象。 |
| `shared_ptr<T>p(q)`    | `p`是`shared_ptr q`的拷贝；此操作会**递增**`q`中的计数器。`q`中的指针必须能转换为`T*` |
| `p = q`                | `p`和`q`都是`shared_ptr`，所保存的指针必须能互相转换。此操作会**递减**`p`的引用计数，**递增**`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放。 |
| `p.unique()`           | 若`p.use_count()`是1，返回`true`；否则返回`false`            |
| `p.use_count()`        | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试。    |

- **使用动态内存的三种原因**：
  - 程序不知道自己需要使用多少对象（比如容器类）。
  - 程序不知道所需要对象的准确类型。
  - 程序需要在多个对象间共享数据。

#### 直接管理内存

- 用`new`动态分配和初始化对象。
  - `new`无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。
  - `int *pi = new int(123);`
  - 一旦内存耗尽，会抛出类型是`bad_alloc`的异常。
- 用`delete`将动态内存归还给系统。
  - 接受一个指针，指向要释放的对象。
  - `delete`后的指针称为空悬指针（dangling pointer）。
- 使用`new`和`delete`管理动态内存存在三个常见问题：
  - 1.忘记`delete`内存。
  - 2.使用已经释放掉的对象。
  - 3.同一块内存释放两次。
- 坚持只使用智能指针可以避免上述所有问题。

#### shared_ptr和new结合使用

**定义和改变shared_ptr的其他方法**：

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `shared_ptr<T> p(q)`     | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，且能够转换为`T*`类型 |
| `shared_ptr<T> p(u)`     | `p`从`unique_ptr u`那里接管了对象的所有权；将`u`置为空       |
| `shared_ptr<T> p(q, d)`  | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete`。 |
| `shared_ptr<T> p(p2, d)` | `p`是`shared_ptr p2`的拷贝，唯一的区别是`p`将可调用对象`d`来代替`delete`。 |
| `p.reset()`              | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。若传递了可选的参数内置指针`q`，会令`p`指向`q`，否则会将`p`置空。若还传递了参数`d`，则会调用`d`而不是`delete`来释放`q`。 |
| `p.reset(q)`             | 同上                                                         |
| `p.reset(q, d)`          | 同上                                                         |

#### 智能指针和异常

- 如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。
- **智能指针陷阱**：
  - 不用相同的内置指针初始化（或`reset`）多个智能指针
  - 不`delete get()`返回的指针。
  - 如果你使用`get()`返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。
  - 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除器。

#### unique_ptr

- 某一个时刻只能有一个`unique_ptr`指向一个给定的对象。
- 不支持拷贝或者赋值操作。
- 向后兼容：`auto_ptr`：老版本，具有`unique_ptr`的部分特性。特别是，不能在容器中保存`auto_ptr`，也不能从函数返回`auto_ptr`。

**unique_ptr操作**:

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `unique_ptr<T> u1`      | 空`unique_ptr`，可以指向类型是`T`的对象。`u1`会使用`delete`来是释放它的指针。 |
| `unique_ptr<T, D> u2`   | `u2`会使用一个类型为`D`的可调用对象来释放它的指针。          |
| `unique_ptr<T, D> u(d)` | 空`unique_ptr`，指向类型为`T`的对象，用类型为`D`的对象`d`代替`delete` |
| `u = nullptr`           | 释放`u`指向的对象，将`u`置为空。                             |
| `u.release()`           | `u`放弃对指针的控制权，返回指针，并将`u`置空。               |
| `u.reset()`             | 释放`u`指向的对象                                            |
| `u.reset(q)`            | 令`u`指向`q`指向的对象                                       |
| `u.reset(nullptr)`      | 将`u`置空                                                    |

#### weak_ptr

- `weak_ptr`是一种不控制所指向对象生存期的智能指针。
- 指向一个由`shared_ptr`管理的对象，不改变`shared_ptr`的引用计数。
- 一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放，不管有没有`weak_ptr`指向该对象。

**weak_ptr操作**:

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `weak_ptr<T> w`     | 空`weak_ptr`可以指向类型为`T`的对象                          |
| `weak_ptr<T> w(sp)` | 与`shared_ptr`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型。 |
| `w = p`             | `p`可以是`shared_ptr`或一个`weak_ptr`。赋值后`w`和`p`共享对象。 |
| `w.reset()`         | 将`w`置为空。                                                |
| `w.use_count()`     | 与`w`共享对象的`shared_ptr`的数量。                          |
| `w.expired()`       | 若`w.use_count()`为0，返回`true`，否则返回`false`            |
| `w.lock()`          | 如果`expired`为`true`，则返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr`。 |

### 动态数组

#### new和数组

- `new`一个动态数组：
  - 类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。
  - 返回**指向第一个对象的指针**。
  - `int *p = new int[size];`

- `delete`一个动态数组：
  - `delete [] p;`

- `unique_ptr`和数组：
  - 指向数组的`unique_ptr`不支持成员访问运算符（点和箭头）。

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `unique_ptr<T[]> u`    | `u`可以指向一个动态分配的数组，整数元素类型为`T`             |
| `unique_ptr<T[]> u(p)` | `u`指向内置指针`p`所指向的动态分配的数组。`p`必须能转换为类型`T*`。 |
| `u[i]`                 | 返回`u`拥有的数组中位置`i`处的对象。`u`必须指向一个数组。    |

#### allocator类

- 标准库`allocator`类定义在头文件`memory`中，帮助我们将内存分配和对象构造分离开。
- 分配的是原始的、未构造的内存。
- `allocator`是一个模板。
- `allocator<string> alloc;`

**标准库allocator类及其算法**：

| 操作                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `allocator<T> a`       | 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存 |
| `a.allocate(n)`        | 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象。     |
| `a.deallocate(p, n)`   | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；`p`必须是一个先前由`allocate`返回的指针。且`n`必须是`p`创建时所要求的大小。在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy`。 |
| `a.construct(p, args)` | `p`必须是一个类型是`T*`的指针，指向一块原始内存；`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象。 |
| `a.destroy(p)`         | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数。     |

**allocator伴随算法**：

| 操作                             | 解释                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `uninitialized_copy(b, e, b2)`   | 从迭代器`b`和`e`给定的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中。`b2`指向的内存必须足够大，能够容纳输入序列中元素的拷贝。 |
| `uninitialized_copy_n(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中。 |
| `uninitialized_fill(b, e, t)`    | 在迭代器`b`和`e`执行的原始内存范围中创建对象，对象的值均为`t`的拷贝。 |
| `uninitialized_fill_n(b, n, t)`  | 从迭代器`b`指向的内存地址开始创建`n`个对象。`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。 |

- 定义在头文件`memory`中。
- 在给定目的位置创建元素，而不是由系统分配内存给他们。



## 第15章 面向对象程序设计

### OOP：概述

- 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
- **继承**（inheritance）：
  - 通过继承联系在一起的类构成一种层次关系。
  - 通常在层次关系的根部有一个**基类**（base class）。
  - 其他类直接或者简介从基类继承而来，这些继承得到的类成为**派生类**（derived class）。
  - 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
  - 对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成**虚函数**（virtual function）。
  - 派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。`class Bulk_quote : public Quote{};`
  - 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- **动态绑定**（dynamic binding，又称运行时绑定）：
  - 使用同一段代码可以分别处理基类和派生类的对象。
  - 函数的运行版本由实参决定，即在运行时选择函数的版本。

### 定义基类和派生类

#### 定义基类

- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
- 基类通过在其成员函数的声明语句前加上关键字`virtual`使得该函数执行**动态绑定**。
- 如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。
- 访问控制：
  - `protected` ： 基类和和其派生类还有友元可以访问。
  - `private` ： 只有基类本身和友元可以访问。

#### 定义派生类

- 派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：`public`、`protected`、`private`。
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- 派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。
- 静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。
- 派生类的声明：声明中不包含它的派生列表。
- C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字`final`。

#### 类型转换与继承

- 理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。
- 可以将基类的指针或引用绑定到派生类对象上。
- 不存在从基类向派生类的隐式类型转换。
- 派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。

### 虚函数

- 使用虚函数可以执行动态绑定。
- OOP的核心思想是多态性（polymorphism）。
- 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
- 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- 如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上`override`可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。
- 通常，只有成员函数（或友元）中的代码才需要使用**作用域运算符**（`::`）来回避虚函数的机制。

### 抽象基类

- **纯虚函数**（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写`=0`就可以将一个虚函数说明为纯虚函数。
- 含有纯虚函数的类是**抽象基类**（abstract base class）。不能创建抽象基类的对象。

### 访问控制与继承

- 受保护的成员：
  - `protected`说明符可以看做是`public`和`private`中的产物。
  - 类似于私有成员，受保护的成员对类的用户来说是不可访问的。
  - 类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。
- 派生访问说明符：
  - 对于派生类的成员（及友元）能否访问其直接积累的成员没什么影响。
  - 派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如`struct Priv_Drev: private Base{}`意味着在派生类`Priv_Drev`中，从`Base`继承而来的部分都是`private`的。
- 友元关系不能继承。
- 改变个别成员的可访问性：使用`using`。
- 默认情况下，使用`class`关键字定义的派生类是私有继承的；使用`struct`关键字定义的派生类是公有继承的。

### 继承中的类作用域

- 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。
- 派生类的成员将隐藏同名的基类成员。
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

### 构造函数与拷贝控制

#### 虚析构函数

- 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。
- 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。
- 虚析构函数将阻止合成移动操作。

#### 合成拷贝控制与继承

- 基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。

#### 派生类的拷贝控制成员

- 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- 派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。

#### 继承的构造函数

- C++11新标准中，派生类可以重用其直接基类定义的构造函数。
- 如`using Disc_quote::Disc_quote;`，注明了要继承`Disc_quote`的构造函数。

### 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。
- 派生类对象直接赋值给积累对象，其中的派生类部分会被切掉。
- 在容器中放置（智能）指针而非对象。
- 对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。


### 文本查询程序再探

- 使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。

#### 面向对象的解决方案

- 将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
  - `WordQuery`
  - `NotQuery`
  - `OrQuery`
  - `AndQuery`  
- 这些类包含两个操作：
  - `eval`：接受一个`TextQuery`对象并返回一个`QueryResult`。
  - `rep`：返回基础查询的`string`表示形式。
- 继承和组合：
  - 当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。
  - 类型之间另一种常见的关系是“有一个（Has A）”的关系。
- 对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。

**Query程序设计**:

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `Query`程序接口类和操作 |                                                              |
| `TextQuery`             | 该类读入给定的文件并构建一个查找图。包含一个`query`操作，它接受一个`string`实参，返回一个`QueryResult`对象；该`QueryResult`对象表示`string`出现的行。 |
| `QueryResult`           | 该类保存一个`query`操作的结果。                              |
| `Query`                 | 是一个接口类，指向`Query_base`派生类的对象。                 |
| `Query q(s)`            | 将`Query`对象`q`绑定到一个存放着`string s`的新`WordQuery`对象上。 |
| `q1 & q2`               | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`AndQuery`对象上。 |
| `q1 | q2`               | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`OrQuery`对象上。 |
| `~q`                    | 返回一个`Query`对象，该`Query`绑定到一个存放`q`的新`NotQuery`对象上。 |
| `Query`程序实现类       |                                                              |
| `Query_base`            | 查询类的抽象基类                                             |
| `WordQuery`             | `Query_base`的派生类，用于查找一个给定的单词                 |
| `NotQuery`              | `Query_base`的派生类，用于查找一个给定的单词                 |
| `BinaryQuery`           | `Query_base`的派生类，查询结果是`Query`运算对象没有出现的行的集合 |
| `OrQuery`               | `Query_base`的派生类，返回它的两个运算对象分别出现的行的并集 |
| `AndQuery`              | `Query_base`的派生类，返回它的两个运算对象分别出现的行的交集 |



## 第19章 特殊工具与技术

### 控制内存分配

#### 重载new和delete

* **`new`表达式的工作机理**：

```c++
string *sp = new string("a value"); //分配并初始化一个string对象
string *arr = new string[10];   // 分配10个默认初始化的string对象
```

* 上述代码实际执行了**三步操作**：
  * `new`表达式调用一个名为`operator new`(或`operator new []`)的标准库函数，它分配一块**足够大的**、**原始的**、**未命名的**内存空间以便存储特定类型的对象(或对象的数组)。
  * 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
  * 对象被分配了空间并构造完成，返回一个指向该对象的指针。

* **`delete`表达式的工作机理**：

```c++
delete sp;  // 销毁*sp，然后释放sp指向的内存空间
delete [] arr;  // 销毁数组中的元素，然后释放对应的内存空间
```

* 上述代码实际执行了**两步操作**：
  * 对`sp`所指向的对象或者`arr`所指的数组中的元素执行对应的析构函数。
  * 编译器调用名为`operator delete`(或`operator delete[]`)的标准库函数释放内存空间。
* 当自定义了全局的`operator new`函数和`operator delete`函数后，我们就担负起了控制动态内存分配的职责。这两个函数**必须是正确的**。因为它们是程序整个处理过程中至关重要的一部分。
* 标准库定义了`operator new`函数和`operator delete`函数的8个重载版本：

```c++
// 这些版本可能抛出异常
void *operator new(size_t); // 分配一个对象
void *operator new[](size_t);   // 分配一个数组
void *operator delete(void*) noexcept;  // 释放一个对象
void *operator delete[](void*) noexcept;    // 释放一个数组

// 这些版本承诺不会抛出异常
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&) noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept;
```

* 应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于**全局作用域**或者**类作用域**中。
* **注意：** 提供新的`operator new`函数和`operator delete`函数的目的在于改变内存分配的方式，但是不管怎样，都不能改变`new`运算符和`delete`运算符的基本含义。
* 使用从C语言继承的函数`malloc`和`free`函数能实现以某种方式执行分配内存和释放内存的操作：

```c++
#include <cstdlib>

void *operator new(size_t size) {
    if(void *mem = malloc(size))
        return mme;
    else
        throw bad_alloc();
}

void operator delete(void *mem) noexcept {
    free(mem);
}
```

#### 定位new表达式

* 应该使用new的定位`new(placement new)`形式传递一个地址，定位`new`的形式如下：

```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] {braced initializer list}
// place_address必须是一个指针，同时在initializers中提供一个(可能为空的)以逗号分隔的初始值列表，该初始值列表将用于构造新分配的对象。
```

* 当只传入一个指针类型的实参时，定位`new`表达式构造对象但是不分配内存。
* 调用析构函数会销毁对象，但是不会释放内存。

```c++
string *sp = new string("a value"); // 分配并初始化一个string对象
sp->~string();
```

### 运行时类型识别

* 运行时类型识别`(run-time type identification, RTTI)`的功能由两个运算符实现：
  * `typeid`运算符， 用于返回表达式的类型。
  * `dynamic_cast`运算符，用于将基类的指针或引用安全地转换曾派生类的指针或引用。
* 使用`RTTI`必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。

#### dynamic_cast运算符

* dynamic_cast运算符的使用形式如下：

```c++
dynamic_cast<type*>(e)  // e必须是一个有效的指针
dynamic_cast<type&>(e)  // e必须是一个左值
dynamic_cast<type&&>(e) // e不能是左值
// 以上，type类型必须时一个类类型，并且通常情况下该类型应该含有虚函数。
// e的类型必须符合三个条件中的任意一个，它们是：
// 1. e的类型是目标type的公有派生类；
// 2. e的类型是目标type的共有基类；
// 3. e的类型就是目标type的类型；

// 指针类型的dynamic_cast
// 假设Base类至少含有一个虚函数，Derived是Base的共有派生类。
if (Derived *dp = dynamic_cast<Derived*>(bp)) {
    // 使用dp指向的Derived对象
} else {    // bp指向一个Base对象
    // 使用dp指向的Base对象
}

// 引用类型的dynamic_cast
void f(const Base &b) {
    try {
        const Derived &d = dynamic_cast<const Derived&>(b);
        // 使用b引用的Derived对象
    } catch (bad_cast) {
        // 处理类型转换失败的情况
    }
}
```

* 可以对一个空指针执行`dynamic_cast`，结果是所需类型的空指针。

### typeid运算符

* `typeid运算符(typeid operator)`，它允许程序向表达式提问：**你的对象是什么类型？**
* `typeid`表达式的形式是`typeid(e)`，其中`e`可以是任意表达式或类型的名字，它操作的结果是一个常量对象的引用。它可以作用于任意类型的表达式。
* 通常情况下，使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同：

```c++
Derived *dp = new Derived;
Base *bp = dp;

if (typeid(*bp) == typeid(*dp)) {
    // bp和dp指向同一类型的对象
}

if (typeid(*bp) == typeid(Derived)) {
    // bp实际指向Derived对象
}
```

* 当typeid作用于指针时(而非指针所指向的对象)，返回的结果是该指针的静态编译时类型。

```c++
// 下面的检查永远是失败的：bp的类型是指向Base的指针
if (typeid(bp) == typeid(Derived)) {
    // 永远不会执行
}
```

#### 使用RTTI

* 用途：为具有继承关系的类实现相等运算符时。对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则说这两个对象是相等的。

```c++
// 类的层次关系
class Base {
    friend bool operator==(const Base&, const Base&);
public:
    // Base的接口成员
protected:
    virtual bool equal(const Base&) const;
    // Base的数据成员和其他用于实现的成员
};

class Derived: public Base {
public:
    // Derived的其他接口成员
protected:
    bool equal(const Base&) const;
    // Derived的数据成员和其他用于实现的成员
};

// 类型敏感的相等运算符
bool operator==(const Base &lhs, const Base &rhs) {
    // 如果typeid不相同，返回false；否则虚调用equal
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

// 虚equal函数
bool Derived::equal(const Base &rhs) const {
    auto r = dynamic_cast<const Derived&>(rhs);
    // 执行比较两个Derived对象的操作并返回结果
}

// 基类equal函数
bool Base::equal(const Base &rhs) const {
    // 执行比较Base对象的操作
}
```

#### type_info类

### 枚举类型

* 枚举类型`(enumeration)`使我们可以将一组整型常量组织在一起。枚举属于字面值常量类型。
* **限定作用域的枚举类型(scoped enumeration)**：首先是关键字`enum class(或enum struct)`，随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员列表，最后是一个分号。

```c++
enum class open_modes {input, output, append};
```

* 不限定作用域的枚举类型`(unscoped enumeration)`：省略关键字`class(或struct)`，枚举类型的名字是可选的。

```c++
enum color {red, yellow, green};
enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10};
```

#### 枚举成员

限定作用域的枚举类型，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外不可访问；

在不限定作用域的枚举类型，枚举成员的作用域与枚举类型本身的作用域相同。

```c++
enum color {red,yellow,green};
enum stoplight {red,yellow,green};         // error:重复定义枚举成员
enum class peppers {red,yellow,green};     // right:枚举成员被隐藏了

color eyes = green;    //right
peppers p = green;     //error:peppers的枚举成员不在有效作用域中。color::green在有效作用域中，但类型错误
color hair = color::red;   //right
peppers p2 = peppers::red; //right
```





### 类成员指针

**成员指针**：指可以指向类的非静态成员的指针。

#### 数据成员指针

* 和其他指针一样，在声明成员指针时也使用*来表示当前声明的名字是一个指针。与普通指针不同的时，成员指针还必须包含成员所属的类。

```c++
// pdata可以指向一个常量(非常量)Screen对象的string成员
const string Screen::*pdata;

// C++11
auto pdata = &Screen::contents;
```

* 当我们初始化一个成员指针或为成员指针赋值时，该指针没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时才提供对象的信息。

```c++
Screen myScreen, *pScreen = &myScreen;

auto s = myScreen.*pdata;

s = pScreen->*pdata;
```

#### 成员函数指针

* 因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这些的指针进行函数调用时，括号必不可少：`(C::*p)(parms)`和`(obj.*p)(args)`。

#### 将成员函数用作可调用对象

### 嵌套类

* 一个类可以定义在另一个类的内部，前者称为嵌套类(nested class)或嵌套类型(nested type)。**嵌套类常用于定义作为实现部分的类**。
* 嵌套类是一个独立的类，与外层类基本没有什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。
* 嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。

### union：一种节省空间的类

* `联合(union)`是一种特殊的类。一个`union`可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。**它不能含有引用类型的成员和虚函数**。

```c++
// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
union Token {
    // 默认情况下成员是共有的
    char cval;
    int ival;
    double dval;
}；

```

* `匿名union(anonymous union)`是一个未命名的`union`，并且在右花括号和分号之间没有任何声明。

```c++
union {
    char cval;
    int ival;
    double dval;
};

// 可以直接访问它的成员
cal = 'c';
ival = 42;
```

* **注意：** `匿名union`不能包含受保护的成员或私有成员，也不能定义成员函数。

### 局部类

* `局部类(local class)`：可以定义在某个函数的内部的类。它的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。
* 局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。
* **局部类不能使用函数作用域中的变量。**

```c++
int a, val;
void foo(int val) {
    static inti si;
    enum loc { a = 1024, b};

    // Bar是foo的局部类
    struct Bar {
        Loc locVal; // 正确：使用一个局部类型名
        int barVal;

        void fooBar(Loc l = a) {    // 正确：默认实参是Loc::a
            barVal = val;   // 错误：val是foo的局部变量
            barVal == ::val;    // 正确：使用一个全局对象
            barVal = si;    // 正确：使用一个静态局部对象
            locVal = b; // 正确：使用一个枚举成员
        }
    }；
}

```

### 固有的不可移植的特性

所谓不可移植的特性是指**因机器而异的特性**，当将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。

#### 位域

* 类可以将其(非静态)数据成员定义成**位域(bit-field)**，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
* 位域在内存中的布局是与机器相关的。
* 位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，通常情况下我们使用无符号类型保存一个位域。

```c++
typedef unsigned int Bit;
class File {
    Bit mode: 2;
    Bit modified: 1;
    Bit prot_owner: 3;
    Bit prot_group: 3;
    Bit prot_world: 3;
public:
    enum modes {READ = 01, WRITE = 02, EXECUTE = 03};
    File &open(modes);
    void close();
    void write();
    bool isRead() const;
    void setWrite();
}

// 使用位域
void File::write() {
    modified = 1;
    // ...
}

void File::close() {
    if( modified)
        // ...保存内容
}

File &File::open(File::modes m) {
    mode |= READ;   // 按默认方式设置READ
    // 其他处理
    if(m & WRITE)   // 如果打开了READ和WRITE
        // 按照读/写方式打开文件
    return *this;
}
```

#### volatile限定符

* 当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为`volatile`。关键字`volatile`告诉编译器不应对这样的对象进行优化。
* `const`和`volatile`的一个重要区别是不能使用合成的拷贝/移动构造函数及赋值运算符初始化`volatile`对象或者从`volatile`对象赋值。

#### 链接指示：extern "C"

* `C++`使用`链接指示(linkage directive)`指出任意非`C++`函数所用的语言。
* 要想把`C++`代码和其他语言(包括`C`语言)编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的`C++`编译器是兼容的。
* `C++`从C语言继承的标准库函数可以定义为`C`函数，但并非必须：决定使用`C`还是`C++`实现的`C`标准库，是每个`C++`实现的事情。
* 有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的程序时预处理器定义`__cplusplus`。

```c++
#ifdef __cplusplus
extern "C"
#endif
int strcmp(const char*, const char*);
```
