## 第1章 C++初识

### 1.1 第一个C++程序

* 创建项目
* 创建文件
* 编写代码
* 运行程序

### 1.2 注释

作用：添加说明
两种格式：

    1. 单行注释  //描述信息
    2. 多行注释  /* */

给类加注释

```c++
/**
*@brief
*
*/
```



### 1.3 变量

作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

- 变量定义（define）

- 变量的声明（declaration）

- 名字的作用域

### 1.4 常量

作用：用于记录程序中不可更改的数据
C++定义常量的两种方式：

1. #define 宏常量  ```#define 常量名 常量值```
   * 通常定义在文件上方，表示一个常量
2. const修饰的变量 ```const 数据类型 常量名 = 常量值```
   * 通常在变量定义前加关键字const，修饰变量为常量，不可修改

### 1.5 关键字

或 标识符
作用：关键字是C++中预先保留的单词（标识符

C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`



### 1.6 标识符命名规则

作用：规则

* 标识符不能是关键字
* 标识符只能由字母，数字，下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写


### 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** ``cin >> 变量 ``

示例：

```c++
int main(){
	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << a << endl;
	//浮点型输入
	double d = 0;
	cout << "请输入浮点型变量：" << endl;
	cin >> d;
	cout << d << endl;
	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << ch << endl;
	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << str << endl;
	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量：" << endl;
	cin >> flag;
	cout << flag << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```

## 第2章 变量和基本（数据）类型

C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存
数据类型存在的意义：给变量分配合适的内存空间。避免浪费内存

### 2.1 基本内置类型

基本内置类型包含算术类型（arithmetic type）和空类型（void）

#### 1 算术类型

>  算术类型分为两类：整型（包括字符和布尔）和浮点型



##### 整型

作用：整数类型的数据
C++能表示整型的类型有以下几种，区别在于所占的内存空间不同：
一个字节为8位

| 数据类型          | 占用空间                                    | 取值范围                        |
| ----------------- | ------------------------------------------- | ------------------------------- |
| short短整型       | 2字节                                       | (-2^15~2^15-1)（-32768～32767） |
| int整型           | 4字节                                       | (-2^31~2^31-1)                  |
| long长整型        | win4字节，Linux4字节（32位），8字节（64位） | (-2^31~2^31-1)                  |
| long long长长整型 | 8字节                                       | (-2^63~2^63-1)                  |


#####  sizeof关键字

作用：可以统计数据类型所占用的内存大小
语法：```sizeof(数据类型/变量)```
short<int<=long<=long long

```
int main() {
	cout << "short 类型所占内存空间为： " << sizeof(short) << endl;
	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;
	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;
	cout << "long long 类型所占内存空间为： " << sizeof(long long) << endl;
	system("pause");
	return 0;
}
```


#####  实型（浮点型）

作用：表示小数
浮点型分为两种：

1. 单精度float
2. 双精度double
3. 默认情况下输出小数，只输出6位

两者的区别在于表示的有效数字范围不同

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15-16位有效数字 |

小数点前也算有效数字

```
float f1=3.14f //默认为double

//科学计数法
float f=3e2  //3* 10^2
float f=3e-2 //3* 0.1^2
```

#####  字符型 

作用：字符型变量用于显示单个字符
语法： ```char ch='a'```

```
注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串
```

* C和C++中字符型变量只占用1字节（一个char的大小应该和一个机器字节一样）
* 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII码放入存储单元

示例：

```C++
int main() {
	
	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;
	//ch = "abcde"; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符
	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;
	system("pause");
	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

##### 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```
int main() {
	
	
	cout << "\\" << endl;
	cout << "\tHello" << endl;
	cout << "\n" << endl;
	system("pause");
	return 0;
}
```



#####  字符串型

**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   	char str1[] = "hello world";
   	cout << str1 << endl;
       
   	system("pause");
   	return 0;
   }
   ```

> 注意：C风格的字符串要用双引号括起来


2. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   int main() {
   	string str = "hello world";
   	cout << str << endl;
   	
   	system("pause");
   	return 0;
   }
   ```

> 注意：C++风格字符串，需要加入头文件==#include\<string>==




#####  布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```c++
int main() {
	bool flag = true;
	cout << flag << endl; // 1
	flag = false;
	cout << flag << endl; // 0
	cout << "size of bool = " << sizeof(bool) << endl; //1
	
	system("pause");
	return 0;
}
```






#### 2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种被大多数类型支持，就是将对象从一种给定的类型***转换（convert）***为另一种相关类型

- 非布尔型的算术值赋给布尔型，初始值为0则结果为false，否则为true；布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。布尔与非布尔类型的算术值 （int float char）
- 将浮点数赋给整型，仅保留小数点之前的部分
- 整型赋给浮点型，小数部分记为0
- 赋给无符号类型一个超出它表示范围的值，结果是初始值对无符号类型表示数值总数取模后的余数。
- 赋给带符号类型一个超出它表示范围的值，结果是未定义的（undefined）

- 含有无符号类型的表达式
  - 当一个算术表达式中既有无符号数又有int时，int会转换成无符号数
    - 负数转换成无符号数：结果等于这个负数加上无符号数的模 
  - 不要混用带符号数与无符号数

例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

```
有整数a和b，a对b进行取模或取余运算
1、求整数商：c=a/b
取模运算在计算商值向负无穷方向舍弃小数位
取余运算在计算商值向0方向舍弃小数位
2、计算模或者余数：r=a-(c*b)
注：取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。

mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的

当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。

具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致。
```

在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.

```
计算机中带符号的整数采用二进制的补码进行存储
正数的补码等于其二进制编码
负数的补码等于其绝对值的二进制编码，取反，再加1
在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111
unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。
```


#### 3 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。

- 每个字面值常量都对应着一种数据类型。字面值常量的形式和值决定了它的数据类型。

  - 整型和浮点型字面值。

    - 20 **十进制**
    - 024 **八进制**
    - 0x14 **十六进制**

  - 字符和字符串字面值。

    - 使用空格连接，继承自C。

    - 字符字面值：单引号， `'a'`

    - 字符串字面值：双引号， `"Hello World"`

    - 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则他们实际上是一个整体。

      - 分多行书写字符串。

      ```
      std:cout<<"wow, a really, really long string"
                "literal that spans two lines" <<std::endl;
      ```

  - 转义序列。`\n`、`\t`等。

  - 指定字面值的类型

    - 字符和字符串字面值
      - u : char16_t
      - U : char32_t
      - L : wchar_t
      - u8 : char 
    - 整型字面值
      - u or U : unsigned
      - l or L : long
      - ll or LL : long long
    - 浮点型字面值
      - f or F : float
      - l or L : long double 

  - 布尔字面值。`true`，`false`。

  - 指针字面值。`nullptr`

> 字符串型实际上时常量字符构成的数组，结尾处以`'\0'`结束，所以字符串类型实际上长度比内容多1。

### 2.2 变量

**variable**

作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

地址编号
0x0000       10
a

####  变量定义（define）

  * **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
  * 初始化（initialize）：当对象创建时获得了一个特定的值，我们说这个对象被初始化了
    * 如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化
    * 如果不使用等号，则执行的是直接初始化
    * 如果初始值只有一个，直接初始化与拷贝初始化都可以。如果初始值有多个，一般来说只能使用直接初始化
    * string s1 = "hello"; //拷贝初始化
    * string s2("bye"); //直接初始化

> 初始化与赋值是两个完全不同的操作。初始化的含义是创建变量的同时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来代替

初始化的几种形式

```
  int i=0; //拷贝初始化
  int i={0}; //初始化列表
  int i{0}; //初始化列表
  int i(0); //直接初始化
```

> 一般来说，这几种初始化方法可以等价使用，但：
> 1 当初始值只有一个，拷贝初始化与直接初始化都行，但初始值有多个，一般只能用直接初始化
> 2 如果提供的是一个类内初始值，只能使用拷贝初始化或使用花括号
> 3 如果提供初始元素值的列表，只能在花括号进行列表初始化，不能放在圆括号

```c++
vector<string> v1{"a","an","the"}; //列表初始化
vector<string> v1("a","an","the"); //错误
```

  * 列表初始化

    当用于内置类型的变量时，这种初始化形式有一个重要特点：如果使用初始化列表初始化且初始值存在丢失信息的风险，则编译器报错

  * 默认初始化：如果定义变量时没有指定初值，则变量被默认初始化(default initialized)

    * 内置类型：定义于任何函数体之外，初始化为0；函数体（类）内部的内置类型变量**不被初始化**(uninitialized)，一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝（用int型做测试，g++编译：不报错，但值是随机值）或者以其他形式访问（用指针访问，也不报错，值随机）此类值将引发错误。！！
    * 类的对象如果没有被显示初始化，其值由类决定

```
如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型和变量所在位置决定。

如果是内置类型（int, short等）的变量为被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，**定义在函数体内部的内置变量将不被初始化(uninitialized)，其值时未定义(undefined)的**。
```



####  变量的声明（declaration）

  如果想声明一个变量而非定义它，就在前加extern

```
  extern int i; //声明i而非定义
  int j; //声明并定义j
```

> 变量能且只能被定义一次，但是可以被多次声明

如果在多个文件中使用同一个变量，必须将声明与定义分离。变量的定义必须出现在且只能出现在一个文件中，其他用到该变量的文件必须对其进行声明，但绝不能重复定义。

如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num。
正确的做法是：在任一个文件中定义外部变量num，而在另一文件中用extern对num作外部变量声明。即extern int num;
编译系统由此知道num是一个已在别处定义的外部变量，它先在本文件中找有无外部变量num，如果有，则将其作用域扩展到本行开始。

> par.h

```
#ifndef PAR
#define PAR

int ii=60;

#endif
```

> main.cc

```
#include <iostream>
#include "par.h"

extern int ii;  //将该句注释掉，程序也可以正常运行
int main()
{
    std::cout<<ii<<std::endl;
}
```

> par.h

```
#ifndef PAR
#define PAR

//int ii=60;
extern int ii;
#endif
```

> par.cc

```
#include "par.h"

//extern int ii;
int ii=60;
```

> main.cc

```
#include <iostream>
#include "par.h"

extern int ii;
int main()
{
    std::cout<<ii<<std::endl;
}
```


####  名字的作用域

名字都有作用域。而作用域(scope)是程序的一部分。以花括号分隔

  * 嵌套的作用域
    内层作用域与外层作用域
    * 局部变量会覆盖全局变量
    * 同时存在全局和局部变量时，已定义局部变量的作用域中可用`::reused`显式访问全局变量reused。
    * **但是用到全局变量时，尽量不适用重名的局部变量。**

### 2.3 复合类型

**compound type**

#### 引用

> 一般说的引用是指的左值引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如`int &refVal = val;`。
- 引用**并非对象**，它只是为一个已经存在的对象所起的另外一个名字。因为不是对象，所以不能定义引用的引用。
- 引用必须初始化。
- 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。一旦定义就不能更改绑定为其他的对象
- 并且引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起
- 引用的类型必须和与之绑定的对象严格匹配。
  - 另外1：初始化常量引用时允许用任意表达式做初始值，只要该表达式的结果能转换(convert)成引用类型即可。尤其，允许一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。



#### 指针

> int *p;      //**指向int型对象**的指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。

- 与引用的不同点。

  - 指针本身是一个**对象***，允许对指针进行赋值和拷贝。在指针生命周期内它可以先后指向几个不同的对象
  - 指针无需在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值

- **定义**指针类型： `int *ip1;`，**从右向左读有助于阅读**，`ip1`是指向`int`类型的指针。

- 指针存放某个对象的**地址**。

- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。

- 指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）

  - const是个例外

- 指针的值的四种状态：

  - 1.指向一个对象；

  - 2.指向紧邻对象的下一个位置；

  - 3.空指针；

  - 4.无效指针。

  - >**对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的**

- 指针访问对象： `cout << *p;`输出p指针所指对象的数据， `*`是**解引用符**。

- 空指针不指向任何对象。使用`int *p=nullptr;`来使用空指针。

- > 指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。

- > 赋值语句永远改变的是**左侧**的对象。

- `void*`指针可以存放**任意**对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。

- 其他指针类型必须要与所指对象**严格匹配**。

- 两个指针相减的类型是`ptrdiff_t`。

- 建议：初始化所有指针。

- `int* p1, p2;//*是对p1的修饰，所以p2还是int型`

#### 理解复合类型的声明

- 定义多个变量

```
int i = 1024, *p = &i, &r = i; //i是int型的数，p是int型指针，r是一个int型引用
```



- 指向指针的指针

```c++
int ival = 1024;
int *pi = &ival;
int **ppi = &pi;
```

- 指向指针的引用


### 2.4 const限定符

- 动机：希望定义一些不能被改变值的变量。

#### 1 初始化和const

- const对象**必须初始化**，且**不能被改变**。
- 默认情况下，const对象被设定为仅在文件内有效。多个文件出现了同名const，等于在不同文件中分别定义了独立变量。const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。

#### 2 const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
  - “对const的引用”简称为“常量引用”。只是个简称而已。严格来说，并不存在常量引用 
- 引用的类型必须与其所引用的对象的类型一致。**第一种例外情况就是** 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。code1。只要该表达式能转换成引用类型即可。
  - 理解当一个常量引用被绑定到另外一种类型上时到底发生了什么。code2
    - 编译器创建了临时量对象，ri绑定了一个临时（temporary）对象。
    - 如果ri不是const，如果仍然执行以上操作结果如何？如果ri为非const，则允许对ri赋值，会改变ri所引用的对象的值。但此时ri绑定在临时量上，所以此种行为没有意义，c++将其视为非法，会报错！！！！

> code1

```code1
	int i=42; 
	const int &r1=i;
	const int &r2=42; 
	const int &r3=r1*2
	int &r4=r1*2;//错误，r4是非常量引用
```

> code2

```
double dv=3.14;
const int &ri=dv;

>>>>>>>>>>

const int temp=dv;
const int &ri=temp;
```

- 对const的引用可能引用一个非const对象：常量引用仅对引用可参与的操作做出了限定，对于引用本身是不是一个常量未作限定。
  - 理解：所谓指向常量的指针或引用，不过是指针和引用的“一厢情愿”，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值

```
    int i=42;
    int &r1=i;
    const int &r2=i;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //42 42 42

    r1=0;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //0 0 0
```

> 下面的例子与临时量对象有关

```
    //需要强制类型转换的情况
    double j=42.66;
    const int &r3=j;
    //const int &r2=i;
    std::cout<<j<<","<<r3<<","<<std::endl; //42.66 42

    j=44.66;
    std::cout<<j<<","<<r3<<","<<std::endl; //44.66 42 
    
    
    //不需要强制类型转换的情况
    double i = 10.3;
    const double &i_ = i;
    std::cout<<i<<","<<i_<<","<<std::endl;  //10.3,10.3,   

    i = 12.3;
    std::cout<<i<<","<<i_<<","<<std::endl;  //12.3,12.3  
```

#### 3 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`。
  - 与引用类似，指针的类型必须与所指向对象类型一致，一种例外情况就是允许令一个指向常量的指针指向一个非常量对象
  - double dv=3.14; const double *cp=&dv;//正确，只是不能通过指针修改dv的值 
  - 所谓指向常量的指针或引用，不过是指针和引用的“一厢情愿”，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值
- **const pointer**：指针是对象而引用不是，因此允许把指针本身定义为常量。常量指针必须初始化。指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 `int i = 0; int *const ptr = &i;`
  - 指针本身是个常量，并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。上面的*ptr=1;就可以重新赋值。

#### 4 顶层const

- `顶层const`：指针本身是个常量。更一般的，顶层const可以表示任意的对象是常量
- `底层const`：指针指向的对象是个常量。
  - 拷贝时严格要求相同的底层const资格。

```c++
int i=0;
int *const p1 =&i;   //顶层const
const int ci=42;	 //顶层const
const int *p2=&ci;	 //底层const
const int *const p3=p2; //靠左的const是底层 靠右的const是顶层
const int &r =ci;	 //底层const

//执行拷贝时，常量是顶层还是底层const区别明显，其中，顶层const无影响
//执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没有影响
i=ci;				//正确：拷贝ci，ci是顶层const，对此操作无影响
p2=p3;				//正确：p2 p3指向的对象类型相同，p3顶层const无影响

//执行拷贝时，拷入和拷出对象必须具有相同的底层const，或者两个对象的数据类型必须能转换
//一般来说，非常量可以转换成常量，反之不行
int *p=p3;			//错误：p3包含底层const定义，p没有
p2=p3;				//正确：p2 p3都是底层const
p2=&i;				//正确：int*能转换成const int*
int &r=ci;			//错误：普通int&不能绑定到int常量上
const int &r2=i;	//正确：const int& 可以绑定到普通int上
```

总结：对指针来说，顶层const在赋值拷贝时无影响，主要考虑底层const必须相同！

```c++
const int m = 5;
int * const x = &m; //error，const int*不能转换为int*

const int m = 5;
const int * const x = &m; //right
```





#### 5 `constexpr`和常量表达式（▲可选）

- 常量表达式(const expression)：指值不会改变，且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是否是常量表达式由它的数据类型和初始值共同决定，如：

```c++
const int max_files = 20; //是常量表达式
int staff_size = 27;  //不是常量表达式
const int sz = get_size();  //不是常量表达式
```

- constexpr变量：`C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;         //20是常量表达式
constexpr int limit = mf + 1;  //mf+1是常量表达式
constexpr int sz = size();     //只有当size是一个constexpr函数时，才是一条正确语句
```

如果认定变量是一个常量表达式，就把他声明成constexpr类型

- 字面值类型：算术类型、引用和指针都属于字面值类型
- 指针和constexpr

### 2.5 处理类型

#### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）
- 指针、常量和类型别名

```cpp
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring是char*的别名
const pstring cstr = 0; // 指向char的常量指针
// 如改写为const char *cstr = 0;不正确，为指向const char的指针

// 辅助理解（可代回后加括号）
// const pstring cstr = 0;代回后const (char *) cstr = 0;
// const char *cstr = 0;即为(const char *) cstr = 0;
```

#### auto类型说明符 c++11

- **auto**类型说明符：让编译器**自动推断类型**。auto定义的变量必须有初始值
- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，如果希望是顶层const需要自己加`const`

#### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- 如果对变量加括号，编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。
- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。
- `C++11`

### 2.6 自定义数据类型

#### 类内初始值

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型和变量所在位置决定。

如果是内置类型（int, short等）的变量为被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，**定义在函数体内部的内置变量将不被初始化(uninitialized)，其值时未定义(undefined)的**。

C++11新标准规定可以为数据成员提供一个**类内初始值（in-class initializer）**。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被**默认初始化**。

1、类内初始值和赋值类似，或者放在**花括号里（如数组）**，或者放在**等号右边**，不能使用圆括号。

2、如果在构造方法里面对赋予了类内初始值的变量再次赋值，类内初始值将被覆盖。

```
class Student {
public:
	Student() = default;
	Student(int _age):age(_age) {};
	string name;
	int age = 10;
	int _class {3};
	int grade;
 
	void printInfo() { cout << "age:" << age << ", grade:" << grade << ", class:" << _class << endl; }
};
 
int main() {
	Student student1;
	student1.printInfo();
 
	Student student2(12);
	student2.printInfo();
	return 0;
}
```

上述代码输出：

```
age:10, grade:37, class:3
age:12, grade:24, class:3
```



1）成员变量grade没有被初始化，其值时未定义的，可能为任何值

2）student1对象的age和_class对象均由类内初始值初始化

3）student2对象的age变量的类内初始值被构造方法传递的参数值覆盖



## 第3章 运算符/表达式

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |

### 表达式基础

表达式由一个或多个**运算对象(operand)**组成。字面值和变量是最简单的**表达式(expression)**。把一个**运算符(operator)**和一个或多个运算对象结合起来可以生成复杂的表达式。

#### 基本概念

- c++定义了一元运算符（unary operator）和二元运算符（binary operator）
- **运算对象转换**：小整数类型会被提升为较大的整数类型
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
  - C中原意：左值**可以**在表达式左边，右值不能。
  - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。

#### 优先级与结合律

- **优先级与结合律**

#### 求值顺序

- **求值顺序**：`int i = f1() + f2()`
  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义
  - 有4中运算符明确规定了运算对象的求值顺序
    - && ：它规定了先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧
    - ||
    - (?:)
    - , 

### 运算符
#### 3.1 算术运算符

算术运算符的运算对象和求值结果都是**右值**

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

- **bool类型不应该参与计算**

  ```cpp
  bool b=true;
  bool b2=-b;   //仍然为true
  //b为true，提升为对应int=1，-b=-1
  //b2=-1≠0，所以b2仍未true
  ```

- 取余运算m%n，结果符号与m相同

- 作用：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
//加减乘除
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除结果依然是整数，小数部分舍去
	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl;  //0
	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; //报错，除数不可以为0
	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout << d1 / d2 << endl;  //2。运算的结果也可以是小数
	system("pause");
	return 0;
}
```

> 总结：在除法运算中，除数不能为0




**示例2：**

```C++
//取模
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << 10 % 3 << endl;    //1
	int a2 = 10;
	int b2 = 20;
	cout << a2 % b2 << endl;   //10
	int a3 = 10;
	int b3 = 0;
	//cout << a3 % b3 << endl; //取模运算时，除数也不能为0
	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;
	//cout << d1 % d2 << endl;
	system("pause");
	return 0;
}
```

> 总结：只有整型变量可以进行取模运算


**示例3：**

```C++
//递增
int main() {
	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11
	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11
	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << a2 << endl;  //11
	cout << b2 << endl;  //110
	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << a3 << endl;  //11
	cout << b3 << endl;	 //100
	system("pause");
	return 0;
}
```



> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反








#### 3.2 赋值运算符

- 赋值运算的**返回结果是它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，使用其当条件时应该加括号。
- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响）
  任意复合运算符op等价于`a = a op b;`
  **作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |



**示例：**

```C++
int main() {
	//赋值运算符
	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;
	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl; //12
	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;  //8
	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;
	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;
	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;
	system("pause");
	return 0;
}
```









#### 3.3 比较运算符

运算对象和求值结果都是右值
**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {
	int a = 10;
	int b = 20;
	cout << (a == b) << endl; // 0 
	cout << (a != b) << endl; // 1
	cout << (a > b) << endl; // 0
	cout << (a < b) << endl; // 1
	cout << (a >= b) << endl; // 0
	cout << (a <= b) << endl; // 1
	
	system("pause");
	return 0;
}
```



> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 












#### 3.4 逻辑运算符

运算对象和求值结果都是右值
**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |


- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**

- 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。

```c++
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {
	int a = 10;
	cout << !a << endl; // 0
	cout << !!a << endl; // 1
	system("pause");
	return 0;
}
```

> 总结： 真变假，假变真




**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {
	int a = 10;
	int b = 10;
	cout << (a && b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a && b) << endl;// 0 
	a = 0;
	b = 0;
	cout << (a && b) << endl;// 0
	system("pause");
	return 0;
}
```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==






**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {
	int a = 10;
	int b = 10;
	cout << (a || b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a || b) << endl;// 1 
	a = 0;
	b = 0;
	cout << (a || b) << endl;// 0
	system("pause");
	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==


#### 递增递减运算符

必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置对象则将对象原始值的副本作为右值返回。

* 前置版本`j = ++i`，先加一后赋值
* 后置版本`j = i++`，先赋值后加一
* 后置递增运算符优先级高于解引用运算符 *ptr++ 等价于 *(prt++)


**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

`*iter++`等价于`*(iter++)`，递增优先级较高

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性


#### 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号


#### 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

#### 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

应用：

```c++
unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
1UL << 12;  // 代表第12个学生通过
quiz1 |= (1UL << 12);   // 将第12个学生置为已通过
quiz1 &= ~(1UL << 12);  // 将第12个学生修改为未通过
bool stu12 = quiz1 & (1UL << 12);   // 判断第12个学生是否通过
```

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。


#### 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。


### 类型转换

#### 1 隐式类型转换

> 设计为尽可能避免损失精度，即转换为更精细类型。

下面情况中，编译器会自动地转换运算对象的类型：

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有转换。

##### 1.1 算术转换

算术转换的含义是把一种算术类型转换成另外一种算术类型。前文数据类型中已经提到

- 整型提升

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

##### 1.2 其他转换

> p143

- 数组转换成指针
- 指针的转换
- 转成布尔
- 转成常量：指针与引用。相反不可以，因为它试图删除底层const
- 类类型定义的转换

#### 2 显式类型转换（尽量避免）

强制类型转换cast

##### 命名的强制类型转换

```c++
cast-name<type>(expression)
```

type-目标类型

expression-待转换的值

cast-name:

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

- **dynamic_cast**：支持运行时类型识别。

- **const_cast**：只能改变运算对象的**底层const**，一般可用于去除const性质(cast away the const)。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

##### 旧式强制类型转换

```
type (expr) //函数形式的强制类型转换
(type) expr //c语言风格
```
### 运算符优先级表
p147

## 第4章 程序流程结构（语句）

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码



### 4.1 选择结构（条件语句）

#### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句

- **悬垂else**（dangling else）：用来描述在嵌套的`if else`语句中，如果`if`比`else`多时如何处理的问题。C++使用的方法是`else`匹配最近没有配对的`if`。--使用花括号

1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002.png)

   示例：

   ```C++
   int main() {
   	//选择结构-单行if语句
   	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   	int score = 0;
   	cout << "请输入一个分数：" << endl;
   	cin >> score;
   	cout << "您输入的分数为： " << score << endl;
   	//if语句
   	//注意事项，在if判断语句后面，不要加分号
   	if (score > 600)  //此处如果加分号，大括号内一定会运行
   	{
   		cout << "我考上了一本大学！！！" << endl;
   	}
   	system("pause");
   	return 0;
   }
   ```

   


> 注意：if条件表达式后不要加分号






2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541662519170.png)



示例：

```C++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else
	{
		cout << "我未考上一本大学" << endl;
	}
	system("pause");
	return 0;
}
```











3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541662566808.png)







示例：

```C++
	int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```









**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断



案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。



**示例：**

```c++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
		if (score > 700)
		{
			cout << "我考上了北大" << endl;
		}
		else if (score > 650)
		{
			cout << "我考上了清华" << endl;
		}
		else
		{
			cout << "我考上了人大" << endl;
		}
		
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```







**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/三只小猪.jpg)









#### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {
	int a = 10;
	int b = 20;
	int c = 0;
	c = (a > b ? a : b);
	cout << "c = " << c << endl;
	//C++中三目运算符返回的是变量,可以继续赋值
	(a > b ? a : b) = 100;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	system("pause");
	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰








#### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch(表达式)   //表达式只能为整型或字符型，不可以是区间
{
	case 结果1：执行语句;break;  //若不加break，会继续执行后面的
	case 结果2：执行语句;break;  //执行语句若为多行，必须加{}
	...
	default:执行语句;break;
}
```

- 如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或是遇到一条break为止





**示例：**

```C++
int main() {
	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片
	int score = 0;
	cout << "请给电影打分" << endl;
	cin >> score;
	switch (score)
	{
	case 10:
	case 9:
		cout << "经典" << endl;
		break;   //退出当前分支
	case 8:
		cout << "非常好" << endl;
		break;
	case 7:
	case 6:
		cout << "一般" << endl;
		break;
	default:
		cout << "烂片" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



> 注意1：switch语句中表达式类型只能是整型或者字符型
> 注意2：case里如果没有break，那么程序会一直向下执行
> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间





### 4.2 循环结构

- **while**：当不确定到底要迭代多少次时，使用 `while`循环比较合适，比如读取输入的内容。
- **for**： `for`语句可以省略掉 `init-statement`， `condition`和 `expression`的任何一个；**甚至全部**。
- **范围for**： `for (declaration: expression) statement`

#### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541668640382.png)







**示例：**

```C++
int main() {
	int num = 0;
	while (num < 10)
	{
		cout << "num = " << num << endl;
		num++;
	}
	
	system("pause");
	return 0;
}
```



> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环








**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。



![猜数字](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/猜数字.jpg)

















#### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![img](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/clip_image002-1541671163478.png)



**示例：**

```C++
int main() {
	int num = 0;
	do
	{
		cout << num << endl;
		num++;
	} while (num < 10);
	
	
	system("pause");
	return 0;
}
```



> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件












**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数

将一个多位数每个位置取出： num%10---个位    num/10 %10 （反复做即可）---十位



















#### 4.2.3 for循环语句

**作用：** 满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`
//起始条件可没有

- **范围for**： `for (declaration: expression) statement`

**示例：**

```C++
int main() {
	for (int i = 0; i < 10; i++)
	{
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```







**详解：**

![1541673704101](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/1541673704101.png)



> 注意：for循环中的表达式，要用分号进行分隔
> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用










**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![timg](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/timg.gif)













#### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![1541676003486](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/1541676003486.png)











**示例：**

```C++
int main() {
	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			cout << "*" << " ";
		}
		cout << endl;
	}
	system("pause");
	return 0;
}
```













**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![0006018857256120_b](/home/casicapollo/Documents/GitHub/cpp/2.C++Primer/1.C++基础入门/assets/0006018857256120_b.jpg)





### 4.3 跳转语句

- **break**：`break`语句负责终止离它最近的`while`、`do while`、`for`或者`switch`语句，并从这些语句之后的第一条语句开始继续执行。
- **continue**：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在`while`、`do while`、`for`循环的内部。

#### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句

for

while

do while

switch

**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;
	int num = 0;
	cin >> num;
	switch (num)
	{
	case 1:
		cout << "您选择的是普通难度" << endl;
		break;
	case 2:
		cout << "您选择的是中等难度" << endl;
		break;
	case 3:
		cout << "您选择的是困难难度" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout << i << endl;
	}
	system("pause");
	return 0;
}
```



**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	system("pause");
	return 0;
}
```















#### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

for

while

do while

**示例：**

```C++
int main() {
	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;  //进行筛选
		}
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```



> 注意：continue并没有使整个循环终止，而break会跳出循环










#### 4.3.3 goto语句

**作用：**可以无条件跳转语句



**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置



**示例：**

```C++
int main() {
	cout << "1" << endl;
	goto FLAG;
	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;
	FLAG:
	cout << "5" << endl;
	
	system("pause");
	return 0;
}
```



> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱



### 4.4 try语句块和异常处理

- **throw表达式**：异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常。

```c++
if(0)
{
    // 抛出异常并终止当前函数
    throw runtime_error("Data wrong!");
}
```

- **try语句块**：以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为**异常处理代码**。
- **异常类**：用于在 `throw`表达式和相关的 `catch`子句之间传递异常的具体信息。



## 第5章 字符串、向量和数组

### using声明

- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。

### string

- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。

#### 定义和初始化string对象

初始化`string`对象的方式：

| 方式                  | 解释                                                    |
| :-------------------- | ------------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是个空字符串                            |
| `string s2(s1)`       | `s2`是`s1`的副本                                        |
| `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
| `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。

#### string对象上的操作

`string`的操作：

| 操作                 | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
| `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`           | 返回`s`中字符的个数                                          |
| `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
| `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
| `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2`             | 同上                                                         |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

- string io：
  - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
  - `getline`：读取一整行，**包括空白符**。
- `s.size()`返回的时`string::size_type`类型，记住是一个**无符号**类型的值，不要和`int`混用
- `s1+s2`使用时，保证至少一侧是string类型。`string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`
- **字符串字面值和string是不同的类型。**

#### 处理string对象中的字符

- **ctype.h vs. cctype**：C++修改了c的标准库，名称为去掉`.h`，前面加`c`。

  > 如c++版本为`cctype`，c版本为`ctype.h`

  - **尽量使用c++版本的头文件**，即`cctype`

`cctype`头文件中定义了一组标准函数：

| 函数          | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
| `isalpha(c)`  | 当`c`是字母时为真                                            |
| `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
| `isdigit(c)`  | 当`c`是数字时为真                                            |
| `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
| `islower(c)`  | 当`c`是小写字母时为真                                        |
| `isprint(c)`  | 当`c`是可打印字符时为真                                      |
| `ispunct(c)`  | 当`c`是标点符号时为真                                        |
| `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)`  | 当`c`是大写字母时为真                                        |
| `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
| `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
| `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

- 遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符。 （C++11）
- `str[x]`,[]输入参数为`string::size_type`类型，给出`int`整型也会自动转化为该类型

### vector

- vector是一个**容器**，也是一个类模板；
- `#include <vector>` 然后 `using std::vector;`
- 容器：包含其他对象。
- 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。

#### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
| `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
| `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
| `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

- 列表初始化： `vector<string> v{"a", "an", "the"};` （C++11）

#### 向vector对象中添加元素

- `v.push_back(e)` 在尾部增加元素。

#### 其他vector操作

`vector`支持的操作：

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`         | 返回`v`中元素的个数                                          |
| `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
| `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2`         | 同上                                                         |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

### 迭代器iterator

- 所有标准库容器都可以使用迭代器。
- 类似于指针类型，迭代器也提供了对对象的间接访问。

#### 使用迭代器

- `vector<int>::iterator iter`。
- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。
- 养成使用迭代器和`!=`的习惯（泛型编程）。
- **容器**：可以包含其他对象；但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。
- **const_iterator**：只能读取容器内元素不能改变。
- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`
- **谨记**：但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。

标准容器迭代器的运算符:

| 运算符           | 解释                                   |
| ---------------- | -------------------------------------- |
| `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem`      | 等价于`(*iter).mem`                    |
| `++iter`         | 令`iter`指示容器中的下一个元素         |
| `--iter`         | 令`iter`指示容器中的上一个元素         |
| `iter1 == iter2` | 判断两个迭代器是否相等                 |

#### 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符               | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |

- **difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。

### 数组

- 相当于vector的低级版，**长度固定**。

#### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是const表达式，或者不写，让编译器自己推断。
- 数组不允许直接赋值给另一个数组。

#### 访问数组元素

- 数组下标的类型：`size_t` 。
- 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。

#### 数组和指针

- 使用数组时，编译器一般会把它转换成指针。
- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 
- **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。

### C风格字符串

- 从C继承来的字符串。
- 用空字符结束（`\0`）。
- 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效。
- 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 。

C标准库String函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

 **尽量使用vector和迭代器，少用数组**

### 多维数组

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...}`。
- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。

### 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

### 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

### 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。





## 第6章 函数




### 6.1 函数基础

- **函数定义**：包括返回类型(return type)、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体(function body)。

```C++
返回值类型 函数名 （参数列表）
{
       函数体语句
       return表达式
}
```

- **调用运算符**(call operator)：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
  - 执行函数的第一步是（隐式）定义并初始化它的形参
- **形参和实参**：实参是形参的初始值。形参和实参的**个数**和**类型**必须匹配上。
- 函数的形参列表： 
```c++
void f() {}		//隐式定义空形参列表
void f(void) {} //显式定义空形参列表
```
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型**不能是数组类型或者函数类型**，**但可以是指向数组或者函数的指针**。



#### 局部对象

- **生命周期**(lifetime)：对象的生命周期是程序执行过程中该对象存在的一段时间。（名字有作用域）
	- 名字的作用域是程序文本的一部分，名字在其中可见
	- 对象的声明周期是程序执行过程中该对象存在的一段时间
	- **局部变量**（local variable）。函数体是一个语句块。块构成一个新的作用域。形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的。同时局部变量会**隐藏**（hide）在外层作用域中的同名的其他所有声明。
- **自动对象**（automatic object）：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
	- 形参是一种自动对象。
	- 用传递给函数的实参初始化形参对应的自动对象。局部变量对应的自动对象，分两种情况：如果变量定义本身函数初始值，则初始化；否则，执行默认初始化，这意味着，内置类型的未初始化的局部变量将产生未定义的值。
- **局部静态对象**（local static object）： `static`类型的局部变量，生命周期贯穿函数调用前后。直到程序终止被销毁

#### 函数声明

- **函数声明**：函数的名字也必须在使用前声明。函数的声明和定义唯一的区别是声明无需函数体，也无须形参的名字，用一个分号替代。
	- 函数声明主要用于描述函数的三要素（返回类型、函数名、形参类型）即定义了函数的接口，也称**函数原型**（function prototype）。
	- 函数的声明不包含函数体，所以无须形参的的名字
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**（separate compilation）： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

### 6.2 参数传递

- 每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。形参初始化的机理和变量初始化一样
- 如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

#### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。
	- 指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。
```c++
#include <iostream>
void fun(int *a)
{
	int i ;
	std::cout<<"i:"<<i<<std::endl;
	int j = i;
	std::cout<<"j:"<<j<<std::endl;
	int *p = &i;
	std::cout<<"*p:"<<*p<<std::endl;	
	int b = 5; 
	a = &b;
	*a = 6;
	//int b = 5; 
	//a = &b;
}
void fun1(int *a)
{
	int i ;
	std::cout<<"i:"<<i<<std::endl;
	int j = i;
	std::cout<<"j:"<<j<<std::endl;
	int *p = &i;
	std::cout<<"*p:"<<*p<<std::endl;	 
	*a = 6;
	int b = 5; 
	a = &b;
}
int main()
{
	int temp = 9;
	fun(&temp);
	std::cout<<"temp:"<<temp;
	fun1(&temp);
	std::cout<<"temp:"<<temp;
	return 0;
}
```

```
i:0
j:0
*p:0
temp:9
i:32766
j:32766
*p:32766
temp:6
```



#### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用避免拷贝
	- 当某种类型不支持拷贝时，函数只能通过引用访问
	- 经常用引用形参来避免不必要的复制。
	- 如果无需改变引用形参的值，最好将其声明为**常量引用**。
- 使用引用形参可以用于**返回额外的信息**。
```
void swap(int &v1, int &v2)
```

#### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。
	- 把函数不会改变的形参定义成（普通）引用是一种比较常见的错误
	- 以上做法带给调用者一种误导，即函数可以修改它的实参的值
	- 此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。
	- 例如，我们不能讲const对象、字面值或者需要类型转换的对象传递给普通的引用形参

#### 数组形参

- 数组有两个性质：不允许拷贝数组、使用数组时通常会将其转换成指针。
- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针；无法以值传递的方式使用数组参数。
- 管理数组形参有三种方法：
	- 1 使用标记指定数组长度：数组本身包含结束标记；
	- 2 使用标准库规范：传递指向数组首尾元素的指针；
	- 3 显示传递一个表示数组大小的形参：专门定义表示数组大小的形参。
- 允许将变量定义成数组的引用
	- f(int &arr [10])   //错误，将arr声明成了引用的数组
	- f(int (&arr) [10])  //正确，arr是具有10个整数的整型数组的引用
- 传递多维数组。

```
int *matrix[10];   //10个指针构成的数组
int (*matrix)[10]; //指向含有10个整数的数组的指针
```

#### main处理命令行选项

有时需要给main函数传递实参。假定main函数位于可执行文件prog内

```
prog -d -o ofile data0
```

- `int main(int argc, char *argv[]){...}`
- `int main(int argc, char **argv){...}`
- 第一个形参，表示数组中字符串的数量，代表参数的个数；第二个形参是参数C风格字符串数组。
- 当实参传递给函数后，argv的第一个元素指向程序的名字或者一个空字符串。接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素保证为0.

```c++
int main(int argc,char **argv)
{
const int m = 5;
const int * const x = &m; //right
        std::cout<<"m:"<<m<<std::endl;
        std::cout<<"argv[0]:"<<argv[0]<<std::endl;
        std::cout<<"argv[1]:"<<argv[1]<<std::endl;
        std::cout<<"argv[2]:"<<argv[2]<<std::endl;
        std::cout<<"argv[3]:"<<argv[3]<<std::endl;
        std::cout<<"argv[4]:"<<argv[4]<<std::endl;
        std::cout<<"argv[5]:"<<argv[5]<<std::endl;
        return 0;
}
```

```
casicapollo@casicapollo-System-Name:~/Documents/test$ ./a.out -d -o ofile data0
m:5
argv[0]:./a.out
argv[1]:-d
argv[2]:-o
argv[3]:ofile
argv[4]:data0
argv[5]:
```



#### 含有可变形参的函数

有时我们无法提前预知应该向函数传递几个参数。

为了编写能处理不同数量实参的函数，C++11提供了两种主要方法：所有的实参类型相同，initializer_list ；实参类型不同， 可变参数模板 ；还有省略符，一般只用于与C函数交互的接口程序

1. `initializer_list`提供的操作（`C++11`）：

实参数量未知但全部实参的类型相同，可以使用 `initializer_list`的标准库类型。

initializer_list对象中的元素永远是常量值

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay"});
```



2. 实参类型不同，可以使用`可变参数模板`。
3. 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。



### 6.3返回类型和return语句

return语句有两种形式

```c++
return;

return expression;

```

#### 无返回值函数

- 没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

- void函数如果想在中间位置提前退出，可以使用return语句，此时return类似于break。
- 一个返回类型是void的函数也能用return语句的第二种形式，不过此时return中的expression必须是另一个返回void的函数

#### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值如何被返回
	- 返回一个值的方式和初始化一个变量或形参的方式完成一样
	- 返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
```c++
const string &manip()
{
	string ret;
	if(!ret.empty())
	{
		return ret;    //error:返回局部对象的引用
	}else{
		return "Empty";//error:“Empty”是一个局部临时变量
	}
}
```
- 返回类类型的函数和调用运算符
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。可以像使用其他左值那样来使用**返回引用的函数的调用**，即能为返回类型是非常量引用的函数的结果赋值。
- **列表初始化返回值**：（`C++11`）函数可以返回花括号包围的值的列表。
```c++
vector<string> process()
{
    if()
    {
        return {};              // 返回空vector
    }else if(){
        return {"fun","okay"};  //返回列表初始化的vector   
    }else{
        return {"fun","okay","oo"};
    }
}
```

- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。

#### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。可以返回数组的指针或引用

```c++
typedef int arrT[10]; //arrT是类型别名，它表示的类型是含有10个int的数组
using arrT=int [10];  //arrT的等价声明
arrT* func(int i);    //func 返回一个指向含有10个int的数组的指针
```

```c++
int arr[10]; 
int *p1[10]; //p1是含有10个指针的数组
int (*p2)[10] =&arr;  //p2是一个指针，指向含有10个int的数组
```

- 声明一个返回数组指针的函数
	- 返回数组指针的函数形式：`Type (*function (parameter_list))[dimension]`
	- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10]；`，然后 `arrT* func() {...}`
	- 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

### 6.4 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
	- `main`函数不能重载。
- 判断两个形参是否相同
- **重载和const形参**：
  - 一个有顶层const的形参和另一个没有顶层const的形参，函数无法区分。
```c++
Record lookup(Phone* const)
Record lookup(Phone*)    //重复声明

Record lookup(const Phone)
Record lookup(Phone)     //重复声明
```
  - 相反，如果形参是指针或引用，通过区分其指向的是常量对象还是非常量对象可以实现函数重载，const是底层的。 
```c++
Record lookup(Account*)
Record lookup(const Account*)  //可以区分。

Record lookup(Account&)
Record lookup(const Account&)  //可以区分。
```
- const_cast和重载

```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1:s2;
}
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string &>(s1),
                           const_cast<const string &>(s2));
    return const_cast<string&>(r);
}
```

首先将实参强转成const引用，然后调用shorterString的const版本，返回const string引用，然后将其转回一个普通string&

- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。

### 6.5 特殊用途语言特性

#### 默认实参

- default argument
```c++
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```
- 在给定的作用域中一个形参只能被赋予一次默认实参。
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：` 返回值类型  函数名 （参数= 默认值）{}`

**示例：**

```C++
int func(int a, int b = 10, int c = 10) {
	return a + b + c;
}

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
	return a + b;
}

int main() {

	cout << "ret = " << func(20, 20) << endl;
	cout << "ret = " << func(100) << endl;

	system("pause");

	return 0;
}
```



#### 内联（inline）函数和constexpr函数
- inline
	- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
	- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
	- `inline`函数应该在头文件中定义。

- constexpr函数

	- 指能用于常量表达式的函数。
	- 函数的返回类型及所有形参类型都要是字面值类型，且函数体内有且只有一个return
	- `constexpr int new_sz() {return 42;}`
	- `constexpr`函数应该在头文件中定义。

#### 调试帮助assert

https://www.runoob.com/w3cnote/c-assert.html

- `assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```



assert() 的用法像是一种"契约式编程"，其表达的意思就是，程序在假设条件下，能够正常良好的运作，其实就相当于一个 if 语句：

```
if(假设成立)
{
     程序正常运行；
}
else
{
      报错&&终止程序！（避免由程序运行引起更大的错误）  
}
```

但是这样写的话，就会有无数个 if 语句，甚至会出现，一个 if 语句的括号从文件头到文件尾，并且大多数情况下，我们要进行验证的假设，只是属于偶然性事件，又或者我们仅仅想测试一下，一些最坏情况是否发生，所以这里有了 assert()。

assert 宏的原型定义在 assert.h 中，其作用是如果它的条件返回错误，则终止程序执行。

```
#include "assert.h" 
void assert( int expression );
```

assert 的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。

使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。 

在调试结束后，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用，示例代码如下： 

```
#include 
#define NDEBUG 
#include
```

**用法总结与注意事项**

**1)在函数开始处检验传入参数的合法性** 

如: 

```
int resetBufferSize(int nNewSize) 
{ 
//功能:改变缓冲区大小, 
//参数:nNewSize 缓冲区新长度 
//返回值:缓冲区当前长度 
//说明:保持原信息内容不变 nNewSize<=0表示清除缓冲区 
assert(nNewSize >= 0); 
assert(nNewSize <= MAX_BUFFER_SIZE); 
 
... 
}
```

**2)每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败** 

不好: 

```
assert(nOffset>=0 && nOffset+nSize<=m_nInfomationSize); 
```

好:

```
assert(nOffset >= 0); 
assert(nOffset+nSize <= m_nInfomationSize); 
```

**3)不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题** 

错误: assert(i++ < 100) 

这是因为如果出错，比如在执行之前i=100,那么这条语句就不会执行，那么i++这条命令就没有执行。 

正确: 

```
assert(i < 100)
i++; 
```

**4)assert和后面的语句应空一行,以形成逻辑和视觉上的一致感** 

**5)有的地方,assert不能代替条件过滤** 　　 

程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。断言assert  是仅在Debug 版本起作用的宏，它用于检查"不应该"发生的情况。以下是一个内存复制程序，在运行过程中，如果assert  的参数为假，那么程序就会中止（一般地还会出现提示对话，说明在什么地方引发了assert）。 

**以下是使用断言的几个原则：** 

- （1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。 
- （2）使用断言对函数的参数进行确认。 
- （3）在编写函数时，要进行反复的考查，并且自问："我打算做哪些假定？"一旦确定了的假定，就要使用断言对假定进行检查。
- （4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果"不可能发生"的事情的确发生了，则要使用断言进行报警。 

ASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0),  程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。  

ASSERT 只有在 Debug 版本中才有效，如果编译为 Release 版本则被忽略。  

### 6.6 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

### 6.7 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。



## 7 类和对象

初始化

拷贝

赋值

销毁

### 7.1 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。

#### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

#### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`
- `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
  - `return *this;`可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

#### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。

#### 类的构造函数



### 7.2 构造与析构

初始化

拷贝

赋值

销毁

#### 7.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



c++利用了**构造函数constructor**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**

类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员。



* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次



#### 7.2.2 构造函数的分类及调用

**1. 两种分类方式：**

- 按参数分为： 
	- 有参构造
	- 无参构造（默认构造）：对参数进行默认初始化。
	- 如果类没有显式定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数，该函数被称为**合成的默认构造函数synthesized default constructor**
		- 如果存在类内初始值，用它来初始化成员
		- 否则，默认初始化该成员（随机值）
	- 某些类不能依赖于合成的默认构造函数
		- 只有当类没有生明任何构造函数时，编译器才会自动生成默认构造
		- 如果类包含内置类型或者复合类型成员，只有当这些成员全被赋予类内初始值，这个类才适合用于使用合成的默认构造函数
		- 有时候编译器不能为某些类合成默认的构造函数。如果类中包含一个其他类类型的成员，并且这个成员的类型没有默认构造函数，那么编译器无法初始化该成员。
- 按类型分为： 
	- 普通构造
	- 和拷贝构造
- 委托构造函数
- **类内初始值**：必须使用=的初始化形式或者花括号括起来的直接初始化形式

**2. 三种调用方式：**

- 括号法

- 显示法

- 隐式转换法



**3. =default的含义**

- 它是一个默认构造函数。
- C++11中，如果我们需要默认的构造函数，就可以通过在参数列表后写上=default来要求编译器生成构造函数。



**4. 委托构造函数**：使用它**所属类**的**其他构造函数**执行它的初始化过程。

- 委托构造函数将自己的职责委托给了其他构造函数。
- `Sale_data(): Sale_data("", 0, 0) {}`

```c++
#include <string>

class Sales_data
{
private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
public:
    // 非委托
    Sales_data(std::string s, unsigned cnt, double price):
            bookNo(s), units_sold(cnt), revenue(cnt*price){}
    // 其余构造函数全都委托给另一个构造函数
    Sales_data(): Sales_data("",0,0){}
    Sales_data(std::string s):Sales_data(s,0,0) {}
    Sales_data(std::istream &is) : Sales_data()
        { read(is,*this);}
};

```



**5. 隐式的类型转换**

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。

```
//Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。在需要使用Sales_data的地方，可以使用string和istream替代
string null_book = "9-999-9999";
// 构造一个临时的Sales_data对象
item.combine(nullbook);
```

这里我们用string实参调用了Sales_data的combine成员。编译器用给定的string自动创建一个Sales_data对象

- 编译器只会自动地执行`仅一步`类型转换。

```
//错误：需要用户定义的两种转换：
//1 把"9-999-9999"转换成string
//2 把这个（临时的）string转换成Sales_data
item.combine("9-999-9999")

//正确，显示转换成string，隐式转换成Sales_data
item.combine(string("9-999-9999"));
//正确，隐式转换成string，显示转换成Sales_data
item.combine(Sales_data("9-999-9999"))
```

- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。只能在类内声明构造函数时使用explicit关键字
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

```c++
class Sales_data{
public:
    Sales_data() = default;
    explict Sales_data(const std::string &s): bookNo(s){};
}
```

此时，没有任何构造函数能够隐式创建Sales_data，下面用法失效

```c++
string null_book = "9-999-9999";
item.combine(nullbook);   //error
```

发生隐式转换的一种情况是我们执行拷贝初始化时（使用=），`explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

```
//发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=），此时我们只能使用直接初始化而不能使用explicit构造函数：
Sales_data item1(null_book); //正确，直接初始化
Sales_data item2 = null_book; //错误，不能将explicit构造函数用于拷贝形式的初始化过程
```

- 为转换显式地使用构造函数

```
item.combine(Sales_data(nullbook));  //right
```



**示例：**

```C++
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system("pause");

	return 0;
}
```

1. 括号法 
   Person p(10);

2. 显示法
   Person p=Person(10);

3. 隐示转换法（只有一个参数的构造函数）
   Person p=10;

4. explict关键字：即3无效
   explict只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显示的，而非隐示的，跟它相对的是implict，即隐式的，类构造函数默认声明为implict
   构造函数参数>=2,无法发生隐式转换，explict失效

  **该关键字还在转换函数的时候用到，用来表示类型转换无效！！！！！！！！！**



#### 7.2.3 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行**值拷贝**



构造函数调用规则如下：

* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造


* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数



示例：

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 7.2.4 拷贝构造函数调用时机



C++中**拷贝构造函数**调用时机通常有三种情况

* 使用一个已经创建完毕的对象来初始化一个新对象（初始化变量）
* 值传递的方式给函数参数传值
* 以值方式返回局部对象



当我们使用赋值运算符时会发生对象的赋值操作。



**示例：**

```C++
class Person {
public:
	Person() {
		cout << "无参构造函数!" << endl;
		mAge = 0;
	}
	Person(int age) {
		cout << "有参构造函数!" << endl;
		mAge = age;
	}
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int *)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout << (int *)&p << endl;
}

int main() {
	//test01();
	//test02();
	test03();
	system("pause");
	return 0;
}
```



#### 7.2.5 深拷贝与浅拷贝



深浅拷贝是面试经典问题，也是常见的一个坑



浅拷贝：简单的赋值拷贝操作



深拷贝：在堆区重新申请空间，进行拷贝操作

**示例1：**

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ) {	
		cout << "有参构造函数!" << endl;
		m_age = age;	
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int m_age;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);  //括号法调用拷贝构造

	cout << "p1的年龄： " << p1.m_age  << endl;

	cout << "p2的年龄： " << p2.m_age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```


**示例2：**
增加堆区的成员变量
但此时在析构函数中没有delete操作，所以此时不报错

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**示例3：**
增加析够，此时报错了

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
			m_height=NULL;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



| p1                                     |                                                      | p2                                 |
| -------------------------------------- | ---------------------------------------------------- | ---------------------------------- |
| int m_age                              | Person p2(p1)                                        | int m_age                          |
| 18                                     | 如果利用编译器提供的拷贝构造，做前拷贝，直接逐字复制 | 18                                 |
| int* m_Height                          | 堆区                                                 | int* m_Height                      |
| 0x0011                                 | 0x0011  160                                          | 0x0011                             |
| p1后被释放，再次释放堆区内存，出现错误 | 浅拷贝带来的问题就是堆区内存重复释放                 | p2先被释放，将堆区释放，此时没问题 |
|                                        | 浅拷贝的问题要通过深拷贝来解决                       |                                    |
|                                        | 0x0022 160                                           | int* m_Height                      |

**示例4：**
提供拷贝构造

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		//这一句为编译器提供
		//m_Height=p.m_Height;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题





#### 7.2.6 初始化列表

对于对象的数据成员，初始化和赋值与变量类似，是两个不同的过程。

如果没有在构造函数的***初始值列表中***显示地初始化成员，则该成员将在***构造函数体之前***执行默认初始化。

即：初始化列表就相当于变量初始化

**作用：**

C++提供了初始化列表语法，用来初始化属性。

**并且有一些情况下，构造函数的初始值必不可少。**

- 成员是const、引用
- 属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`

**注意**：

- 成员初始化顺序
	- 最好让构造函数初始值的顺序和成员声明的顺序保持一致。尽量避免用某些成员初始化其他成员。
```C++
class X
{
	int i;
    int j;
public:
    // 未定义的：i在j之前被初始化
    X(int val):j(val),i(j){}
    
}
```
- 默认实参与构造函数
	- 如果一个构造函数为所有参数都提供了默认实数，那么它实际上也定义了默认的构造函数。



**示例：**

```C++
class Person {
public:

	////传统方式初始化
	//Person(int a, int b, int c) {
	//	m_A = a;
	//	m_B = b;
	//	m_C = c;
	//}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	void PrintPerson() {
		cout << "mA:" << m_A << endl;
		cout << "mB:" << m_B << endl;
		cout << "mC:" << m_C << endl;
	}
private:
	int m_A;
	int m_B;
	int m_C;
};

int main() {

	Person p(1, 2, 3);
	p.PrintPerson();


	system("pause");

	return 0;
}
```


> 初始化列表性能好，推荐使用
> 必须使用初始化列表的时候：
> 1）常量成员const
> 2）引用 。以上两种均为只可以初始化不可以赋值的情况
> 3）没有默认构造函数的类（自定义）类型：直接调用拷贝构造

> 构造函数执行其实是分为两个阶段的：1）初始化阶段；2）普通的计算阶段阶段。
> 初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。计算阶段：一般用于执行构造函数体内的赋值操作
> 1)初始化阶段:初始化列表中显示初始化的成员按照列表中圆括号内的值初始化，而对于初始化列表中没有显式列出的成员，若是类成员，则调用该类型的默认构造函数初始化，若是内置类型或者复合类型，则按照变量初始化的原则，在局部作用域中的不做初始化，全局作用于中的初始化为0。
> 2)普通的计算阶段：一般是指在构造函数的函数体内对数据成员做赋值工作，千万记住，在函数体内进行赋值操作之前，数据成员的初始化已经完成。

https://blog.csdn.net/weixin_34260991/article/details/92153995

    使用常规构造函数赋值类对象：

```
#include <iostream>
using namespace std; 
 
class Test_A
{
public:
	Test_A()
	{
		cout<<"构造函数Test_A()"<<endl;
	}
 
	Test_A(const Test_A& t1)
	{
		cout<<"拷贝构造函数Test_A()"<<endl;
		m_age = t1.m_age;
	}
 
	Test_A& operator = (const Test_A& t1)
	{
		cout<<"重载赋值运算符operator="<<endl;
		m_age = t1.m_age;
		return *this;
	}
 
	~Test_A()
	{
		cout<<"析构函数~Test_A()"<<endl;
	}
public:
	int m_age;
};
 
class Test_B
{
public:
	Test_B(Test_A& t1)
	{
		m_b = t1;
	}
public:
	Test_A m_b;
};
 
/*此函数相当于一个舞台，展示此函数内对象的完整生命周期*/
void display() 
{
	Test_A t1;
	Test_B t2(t1);
}
 
int main()
{
	display();
	system("pause");
	return 0;
}
```

    输出结果：
    构造函数Test_A()
    构造函数Test_A()
    重载赋值运算符operator=
    析构函数~Test_A()
    析构函数~Test_A()

从输出结果中可以看出，在执行Test_B t2(t1)的过程：
先调用Test_A类的构造函数初始化成员对象 m_b                             （初始化阶段）
然后再调用Test_A类的重载赋值运算符函数，将t1赋值给m_b。    （计算阶段）

    使用初始化列表（只需修改类Test_B中的构造函数）：

```
class Test_B
{
public:
	Test_B(Test_A& t1):m_b(t1){};   //使用了构造函数的初始化列表
public:
	Test_A m_b;
};
```

```
输出结果：
构造函数Test_A()
拷贝构造函数Test_A()
析构函数~Test_A()
析构函数~Test_A()
```



### 7.3 this指针

#### 7.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

```C++
class Person {
public:
	Person() {
		mA = 0;
	}
	//非静态成员变量占对象空间
	int mA;
	//静态成员变量不占对象空间
	static int mB; 
	//函数也不占对象空间，所有函数共享一个函数实例
	void func() {
		cout << "mA:" << this->mA << endl;
	}
	//静态成员函数也不占对象空间
	static void sfunc() {
	}
};

int main() {

	cout << sizeof(Person) << endl;

	system("pause");

	return 0;
}
```



#### 7.3.2 this指针概念

在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

A：c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个**非静态成员函数**内的一种指针

this指针不需要定义，直接使用即可

`*this`：

- 每个成员函数都有一个额外的，隐含的形参`this`。
- `this`总是指向当前对象，因此`this`是一个常量指针。
- 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
- `return *this;`可以让成员函数连续调用。
- 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
- `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

this指针的用途：

*  当形参和成员变量同名时，可用this指针来区分  （解决名称冲突）
*  在类的非静态成员函数中返回对象本身，可使用return *this （链式编程。返回对象本身，this指针指向被调用的成员函数所属的对象）

```C++
class Person
{
public:
	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}
	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//this指向p2的指针，*this返回对象本身
		return *this;
	}
	int age;
};

void test01()
{
	Person p1(10);
	cout << "p1.age = " << p1.age << endl;

	Person p2(10);

	//链式编程思想
	//如果上面返回的不是Person& 而是Person，输出为20
	//如果返回值为Person类型，即值传递，那么会调用拷贝构造
             返回p2`               返回p2``             返回p2```
   (             |	     )                    )                   )
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout << "p2.age = " << p2.age << endl;
}

int main() {

	test01();
	system("pause");
	return 0;
}
```



```
total.isbn();  //返回bookNo
```

当我们在调用成员函数时，实际上是在替某个对象调用它。在上面的调用中，实际上隐式地返回total.bookNo。

成员函数通过一个名为**this**的额外的隐式参数来访问**调用它的那个对象**。当我们调用一个成员函数时，用请求该函数的对象的地址初始化this。即

```c++
total.isbn()

Sales_data::isbn(&total)//伪代码
```

在成员函数内部，可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。**任何对类成员的直接访问都被看做this的隐式引用**。

因为this总是指向该对象，所以this是一个常量指针，不允许改变this中保存的地址。





#### 7.3.3 const修饰成员函数



**常函数：**

* 成员函数后加const后我们称为这个函数为**常函数**（常量成员函数）
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改



const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向 类 类型 的 非常量版本 的 常量指针 。 AA * const this

尽管this是隐式的，但仍然需要遵守初始化规则，意味着（在默认情况下）我们不能将this绑定到一个常量对象上（指针指向的对象必须与指针的类型相同。可以用非const来初始化const指针，但反过来不行，此处的情况就是反过来，用const来初始化非const指针）。因此，**不能在一个常量对象上调用普通的成员函数**。

常函数（常量成员函数const member function），加了const之后，this变成 const AA * const this，此时this可以绑定常量对象。

```
常量对象，以及常量对象的引用或指针都只能调用常量成员函数
```



**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数
* 成员属性声明时加关键字mutable后，常对象可以修改

成员属性声明时加关键字mutable后，在常函数中也可以修改





**示例：**

```C++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	//在成员函数后加const，修饰的是this指向，让指针指向的值也不可以修改
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用非const的函数，因为普通成员函数可以修改属性

}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 7.3.4 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

**示例：**

```C++
//空指针访问成员函数
class Person {
public:

	void ShowClassName() {
		cout << "我是Person类!" << endl;
	}
	
	//1.0
	void ShowPersonAge() {
		cout << mAge << endl;
	}
	//2.0
	void ShowPersonAge() {
		if (this == NULL) {
			return;
		}
		cout << mAge << endl;
	}


public:
	int mAge;
};

void test01()
{
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
	p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
					//属性前默认加了this指针，而this是空的，空的指针访问属性，必报错
}

int main() {

	test01();

	system("pause");

	return 0;
}
```







### 7.4 访问控制与封装、友元

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

- 允许特定的**非成员函数**访问一个类的**私有成员**.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 通常将友元声明成组地放在**类定义的开始或者结尾**。
- 类之间的友元：
  - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

友元的目的就是让一个函数或者类 访问另一个类中私有成员



友元的三种实现

* 全局函数做友元
* 类做友元
* 成员函数做友元

##### 全局函数做友元

```C++
class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	friend void goodGay(Building * building);
public:
	Building()
	{
		this->m_SittingRoom = "客厅";
		this->m_BedRoom = "卧室";
	}

public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};

void goodGay(Building * building)
{
	cout << "好基友正在访问： " << building->m_SittingRoom << endl;
	cout << "好基友正在访问： " << building->m_BedRoom << endl;
}

void test01()
{
	Building b;
	goodGay(&b);
}

int main(){
	test01();
	system("pause");
	return 0;
}
```



##### 类做友元

```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	friend class goodGay;
public:
	Building();
public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){
	test01();
	system("pause");
	return 0;
}
```



##### 成员函数做友元

```C++
class Building;
class goodGay
{
public:
	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 
private:
	Building *building;
};

class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	friend void goodGay::visit();
public:
	Building();
public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void goodGay::visit2()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	//cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system("pause");
	return 0;
}
```



#### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

### 7.5 类的其他特性

#### 类成员

- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。
- **可变数据成员** （mutable data member）：
  - `mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。

#### 类类型
- **类类型**：
  - 每个类定义了唯一的类型。

C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员



例如：

```C++
class A {}
class B
{
    A a；
}
```



B类中有对象A作为成员，A为对象成员



那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

> 当类中成员是其他类对象时，我们称该成员为 对象成员
> 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
> 析构顺序与构造相反





**示例1：**
初始化列表

```C++
class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
	}


	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	//Phone m_Phone = pName;//隐式转换法
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三" , "苹果X");

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**示例2：**

```C++
class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
		cout << "Phone构造" << endl;
	}

	~Phone()
	{
		cout << "Phone析构" << endl;
	}

	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout << "Person构造" << endl;
	}

	~Person()
	{
		cout << "Person析构" << endl;
	}

	void playGame()
	{
		cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl;
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三" , "苹果X");
	p.playGame();

}


int main() {

	test01();

	system("pause");

	return 0;
}
```





### 7.6 类的作用域 

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。

### 7.7 类的静态成员

- 非`static`数据成员存在于类类型的每个对象中。
- `static`数据成员独立于该类的任意对象而存在。
- 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。

有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

在成员声明之前加static使得其与类关联在一起。

**静态成员**就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：
（均有访问权限private public）

*  静态成员变量
   *  所有对象共享同一份数据  //改一个全改//访问方式两种
   *  在编译阶段分配内存 全局区
   *  类内声明，类外初始化
*  静态成员函数
   *  所有对象共享同一个函数 //两种访问方式
   *  静态成员函数只能访问静态成员变量 //无法区分到底是哪个对象的非静态成员变量

静态成员函数不与任何对象绑定在一起，**不包含this指针**。**静态成员函数不能声明成const的**，也不能在static函数体内使用this指针



- 声明：
  - 声明之前加上关键词`static`。
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
- 定义：
  - 在类外部定义时不用加`static`。
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义，则要求必须是字面值常量类型的`constexpr`。





**示例1 ：**静态成员变量

```C++
class Person
{
	
public:

	static int m_A; //静态成员变量

	//静态成员变量特点：
	//1 在编译阶段分配内存
	//2 类内声明，类外初始化
	//3 所有对象共享同一份数据
	//4 有访问权限

private:
	static int m_B; //静态成员变量也是有访问权限的
};
int Person::m_A = 10;
int Person::m_B = 10;

void test01()
{
	//静态成员变量 不属于某个对象，所有对象共享同一份数据
	//因此，静态成员变量两种访问方式
	//1 通过对象
	//2 通过类名

	//1、通过对象
	Person p1;
	p1.m_A = 100;
	cout << "p1.m_A = " << p1.m_A << endl;   //100

	Person p2;
	p2.m_A = 200;
	cout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据 //200
	cout << "p2.m_A = " << p2.m_A << endl;

	//2、通过类名
	cout << "m_A = " << Person::m_A << endl;


	//cout << "m_B = " << Person::m_B << endl; //私有权限访问不到
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



**示例2：**静态成员函数

```C++
class Person
{

public:

	//静态成员函数特点：
	//1 程序共享一个函数
	//2 静态成员函数只能访问静态成员变量
	
	static void func()
	{
		cout << "func调用" << endl;
		m_A = 100;   //静态成员函数可以访问静态成员变量
		//m_B = 100; //错误，静态成员函数不可以访问非静态成员变量
	}

	static int m_A; //静态成员变量
	int m_B; // 
private:

	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "func2调用" << endl;
	}
};
int Person::m_A = 10;


void test01()
{
	//静态成员函数两种访问方式

	//1、通过对象
	Person p1;
	p1.func();

	//2、通过类名
	Person::func();


	//Person::func2(); //私有权限访问不到
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

### 静态static总结

https://blog.csdn.net/ypshowm/article/details/89030194
https://blog.csdn.net/majianfei1023/article/details/45290467

c++static关键字的作用
c/c++共有
1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。               
2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。              
3）：修饰函数时，表明该函数只在同一文件中调用。
c++独有：
4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。
5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

1. C 语言的 static 关键字有三种（具体来说是两种）用途：
   1.1. 静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。

```c++
int foo(){
	static int i = 1; // note:1
	//int i = 1;  // note:2
	i += 1;
	return i;
}
```

要明白这个用法，我们首先要了解c/c++的内存分布，以及static所在的区间。

对于一个完整的程序，在内存中的分布情况如下图：　 
1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
3.堆区：程序员分配并释放的区域，像malloc(c),new(c++) 
3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
4.代码区

Q:所以上面note:1的static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？
A:首先回答第一个问题：它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么i就是在栈区分配了，会随着foo的调用结束而释放)。
那么第二个问题也就浮出水面了，它是在第一次调用进入note:1的时候初始化（当初面试被坑过，我居然说是一开始就初始化了，汗！！）。且只初始化一次，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。

那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：
（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);
（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);
（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);
（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);

1.2 静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。


```
static int i = 1;  //note:3
//int i = 1;  //note:4
 
 
int foo()
{
	i += 1;
	return i;
}
```

note:3和note:4有什么差异呢？你调用foo(),无论调用几次，他们的结果都是一样的。也就是说在本文件内调用他们是完全相同的。那么他们的区别是什么呢？
文件隔离！

假设我有一个文件a.c,我们再新建一个b.c,内容如下。

```
//file a.c
 
//static int n = 15;  //note:5
int n = 15;  //note:6
 
//file b.c
#include <stdio.h>
 
extern int n;
//extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
void fn()
{
	n++;
	printf("after: %d\n",n);
}
 
 
void main()
{
	printf("before: %d\n",n);
	fn();
}
```

我们先使用note:6,也就是非静态全局变量，发现输出为:
before: 15
after: 16


也就是我们的b.c通过extern使用了a.c定义的全局变量。
那么我们改成使用note:5,也就是使用静态全局变量呢？

gcc a.c b.c -o output.out

会出现类似undeference to "n"的报错，它是找不到n的，因为static进行了文件隔离，你是没办法访问a.c定义的静态全局变量的，当然你用 #include "a.c",那就不一样了。

以上我们就可以得出静态全局变量的特点：
（1）静态全局变量不能被其它文件所用(全局变量可以);
（2）其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);

1.3 静态函数：准确的说，静态函数跟静态全局变量的作用类似：

```
//file a.c
#include <stdio.h>
 
 
void fn()
{
	printf("this is non-static func in a");
}
 
 
//file b.c
#include <stdio.h>
 
 
extern void fn();  //我们用extern声明其他文件的fn(),供本文件使用。
 
 
void main()
{
	fn();
}
```

可以正常输出：this is non-static func in a。
当给void fn()加上static的关键字之后呢？ undefined reference to "fn".

所以，静态函数的好处跟静态全局变量的好处就类似了：
1.静态函数不能被其它文件所用;
2.其它文件中可以定义相同名字的函数，不会发生冲突;

上面一共说了三种用法，为什么说准确来说是两种呢？
1.一种是修饰变量，一种是修饰函数，所以说是两种（这种解释不多）。
2.静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。


2. C++ 语言的 static 关键字有二种用途：
   当然以上的几种，也可以用在c++中。还有额外的两种用法：

2.1 静态数据成员：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。

```
#include<iostream>
 
 
using namespace std;
 
 
class Rectangle
{
private:
	int m_w,m_h;
	static int s_sum;
	
public:
	Rectangle(int w,int h)
	{
		this->m_w = w;
		this->m_h = h;
		s_sum += (this->m_w * this->m_h);
	}
 
 
	void GetSum()
	{
		cout<<"sum = "<<s_sum<<endl;
	}
 
 
};
 
 
int Rectangle::s_sum = 0;  //初始化
 
 
 
 
int main()
{
	cout<<"sizeof(Rectangle)="<<sizeof(Rectangle)<<endl;
	Rectangle *rect1 = new Rectangle(3,4);
	rect1->GetSum();
	cout<<"sizeof(rect1)="<<sizeof(*rect1)<<endl;
	Rectangle rect2(2,3);
	rect2.GetSum();
	cout<<"sizeof(rect2)="<<sizeof(rect2)<<endl;
	
	system("pause");
	return 0;
}
```

输出

```
sizeof Rectangle=8
sum=12
sizeof rect1=8
sum=18
sizeof rect2=8
```

由图可知：sizeof(Rectangle)=8bytes=sizeof(m_w)+sizeof(m_h)。也就是说 static 并不占用Rectangle的内存空间。
那么static在哪里分配内存的呢？是的，全局数据区(静态区)。
再看看GetSum()，第一次12=3*4，第二次18=12+2*3。由此可得，static只会被初始化一次，于实例无关。

对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。

也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。

2.2 静态成员函数：用于修饰 class 的成员函数。
我们对上面的例子稍加改动：

```
#include<iostream>
 
 
using namespace std;
 
 
class Rectangle
{
private:
	int m_w,m_h;
	static int s_sum;
	
public:
	Rectangle(int w,int h)
	{
		this->m_w = w;
		this->m_h = h;
		s_sum += (this->m_w * this->m_h);
	}
 
 
	static void GetSum()  //这里加上static
	{
		cout<<"sum = "<<s_sum<<endl;
	}
 
 
};
 
 
int Rectangle::s_sum = 0;  //初始化
 
 
 
 
int main()
{
	cout<<"sizeof(Rectangle)="<<sizeof(Rectangle)<<endl;
	Rectangle *rect1 = new Rectangle(3,4);
	rect1->GetSum();
	cout<<"sizeof(rect1)="<<sizeof(*rect1)<<endl;
	Rectangle rect2(2,3);
	rect2.GetSum();  //可以用对象名.函数名访问
	cout<<"sizeof(rect2)="<<sizeof(rect2)<<endl;
	Rectangle::GetSum();  //也可以可以用类名::函数名访问
 
 
	system("pause");
	return 0;
}
```

上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。
那么静态成员函数有特点呢？
1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;
2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;
3.静态成员函数不能访问非静态成员函数和非静态数据成员;
4.调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)

前三点其实是一点：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态，有点晕吗？没关系，我给你个解释，
因为静态是属于类的，它是不知道你创建了10个还是100个对象，所以它对你对象的函数或者数据是一无所知的，所以它没办法调用，而反过来，你创建的对象是对类一清二楚的(不然你怎么从它那里实例化呢)，所以你是可以调用类函数和类成员的，就像不管GetSum是不是static，都可以调用static的s_sum一样。

3. Q&A

（7）静态成员函数与非静态成员函数的区别
答：根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。
（8）为什么要用得静态成员变量和静态成员函数
答：为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享
（9）静态成员的作用、优点
答：静态成员函数主要为了调用方便，不需要生成对象就能调用。





