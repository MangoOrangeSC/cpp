# C++基础入门

## 1 C++初识
### 1.1 第一个C++程序

* 创建项目
* 创建文件
* 编写代码
* 运行程序

### 1.2 注释

作用：添加说明
两种格式：

  1. 单行注释  //描述信息
  2. 多行注释  /* */

### 1.3 变量
作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

- 变量定义（define）

- 变量的声明（declaration）

- 名字的作用域

### 1.4 常量
作用：用于记录程序中不可更改的数据
C++定义常量的两种方式：
1. #define 宏常量  ```#define 常量名 常量值```
    * 通常定义在文件上方，表示一个常量
2. const修饰的变量 ```const 数据类型 常量名 = 常量值```
    * 通常在变量定义前加关键字const，修饰变量为常量，不可修改

### 1.5 关键字
或 标识符
作用：关键字是C++中预先保留的单词（标识符

C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`



### 1.6 标识符命名规则
作用：规则
* 标识符不能是关键字
* 标识符只能由字母，数字，下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写


### 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** ``cin >> 变量 ``

示例：

```c++
int main(){
	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << a << endl;
	//浮点型输入
	double d = 0;
	cout << "请输入浮点型变量：" << endl;
	cin >> d;
	cout << d << endl;
	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << ch << endl;
	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << str << endl;
	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量：" << endl;
	cin >> flag;
	cout << flag << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```

## 2 变量和基本（数据）类型
C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存
数据类型存在的意义：给变量分配合适的内存空间。避免浪费内存

### 2.1 基本内置类型

基本内置类型包含算术类型（arithmetic type）和空类型（void）

#### 1 算术类型

>  算术类型分为两类：整型（包括字符和布尔）和浮点型



##### 整型
作用：整数类型的数据
C++能表示整型的类型有以下几种，区别在于所占的内存空间不同：
一个字节为8位

|数据类型|占用空间|取值范围|
|----|----|----|
|short短整型|2字节|(-2^15~2^15-1)（-32768～32767）|
|int整型|4字节|(-2^31~2^31-1)|
|long长整型|win4字节，Linux4字节（32位），8字节（64位）|(-2^31~2^31-1)|
|long long长长整型|8字节|(-2^63~2^63-1)|


#####  sizeof关键字
作用：可以统计数据类型所占用的内存大小
语法：```sizeof(数据类型/变量)```
short<int<=long<=long long

```
int main() {
	cout << "short 类型所占内存空间为： " << sizeof(short) << endl;
	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;
	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;
	cout << "long long 类型所占内存空间为： " << sizeof(long long) << endl;
	system("pause");
	return 0;
}
```


#####  实型（浮点型）
作用：表示小数
浮点型分为两种：
1. 单精度float
2. 双精度double
3. 默认情况下输出小数，只输出6位

两者的区别在于表示的有效数字范围不同
|数据类型|占用空间|有效数字范围|
|----|----|----|
|float|4字节|7位有效数字|
|double|8字节|15-16位有效数字|

小数点前也算有效数字
```
float f1=3.14f //默认为double

//科学计数法
float f=3e2  //3* 10^2
float f=3e-2 //3* 0.1^2
```

#####  字符型 
作用：字符型变量用于显示单个字符
语法： ```char ch='a'```

```
注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串
```
* C和C++中字符型变量只占用1字节（一个char的大小应该和一个机器字节一样）
* 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII码放入存储单元

示例：

```C++
int main() {
	
	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;
	//ch = "abcde"; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符
	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;
	system("pause");
	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

##### 转义字符
**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```
int main() {
	
	
	cout << "\\" << endl;
	cout << "\tHello" << endl;
	cout << "\n" << endl;
	system("pause");
	return 0;
}
```



#####  字符串型
**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   	char str1[] = "hello world";
   	cout << str1 << endl;
       
   	system("pause");
   	return 0;
   }
   ```

> 注意：C风格的字符串要用双引号括起来


2. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   int main() {
   	string str = "hello world";
   	cout << str << endl;
   	
   	system("pause");
   	return 0;
   }
   ```

> 注意：C++风格字符串，需要加入头文件==#include\<string>==




#####  布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```c++
int main() {
	bool flag = true;
	cout << flag << endl; // 1
	flag = false;
	cout << flag << endl; // 0
	cout << "size of bool = " << sizeof(bool) << endl; //1
	
	system("pause");
	return 0;
}
```






#### 2 类型转换
对象的类型定义了对象能包含的数据和能参与的运算，其中一种被大多数类型支持，就是将对象从一种给定的类型***转换（convert）***为另一种相关类型

- 非布尔型的算术值赋给布尔型，初始值为0则结果为false，否则为true；布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。布尔与非布尔类型的算术值 （int float char）
- 将浮点数赋给整型，仅保留小数点之前的部分
- 整型赋给浮点型，小数部分记为0
- 赋给无符号类型一个超出它表示范围的值，结果是初始值对无符号类型表示数值总数取模后的余数。
- 赋给带符号类型一个超出它表示范围的值，结果是未定义的（undefined）

- 含有无符号类型的表达式
	- 当一个算术表达式中既有无符号数又有int时，int会转换成无符号数
		- 负数转换成无符号数：结果等于这个负数加上无符号数的模 
	- 不要混用带符号数与无符号数

例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

```
有整数a和b，a对b进行取模或取余运算
1、求整数商：c=a/b
取模运算在计算商值向负无穷方向舍弃小数位
取余运算在计算商值向0方向舍弃小数位
2、计算模或者余数：r=a-(c*b)
注：取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。

mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的

当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。

具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致。
```
在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.
```
计算机中带符号的整数采用二进制的补码进行存储
正数的补码等于其二进制编码
负数的补码等于其绝对值的二进制编码，取反，再加1
在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111
unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。
```


#### 3 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  
- 每个字面值常量都对应着一种数据类型。字面值常量的形式和值决定了它的数据类型。
  
  - 整型和浮点型字面值。
  	- 20 **十进制**
  	- 024 **八进制**
  	- 0x14 **十六进制**
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World"`
    - 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则他们实际上是一个整体。
    	- 分多行书写字符串。
      ```
      std:cout<<"wow, a really, really long string"
                "literal that spans two lines" <<std::endl;
      ```
  - 转义序列。`\n`、`\t`等。
  - 指定字面值的类型
  	- 字符和字符串字面值
  		- u : char16_t
  		- U : char32_t
  		- L : wchar_t
  		- u8 : char 
  	- 整型字面值
  		- u or U : unsigned
  		- l or L : long
  		- ll or LL : long long
    - 浮点型字面值
    	- f or F : float
    	- l or L : long double 
  - 布尔字面值。`true`，`false`。
  - 指针字面值。`nullptr`

> 字符串型实际上时常量字符构成的数组，结尾处以`'\0'`结束，所以字符串类型实际上长度比内容多1。

### 2.2 变量
作用：给一端指定的内存空间起名，方便操作这段内存
语法： 数据类型 变量名 = 初始量;

地址编号
0x0000       10
a

####  变量定义（define）
  * **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
  * 初始化（initialize）：当对象创建时获得了一个特定的值，我们说这个对象被初始化了
    * 如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化
    * 如果不使用等号，则执行的是直接初始化
    * 如果初始值只有一个，直接初始化与拷贝初始化都可以。如果初始值有多个，一般来说只能使用直接初始化
    * string s1 = "hello"; //拷贝初始化
    * string s2("bye"); //直接初始化
> 初始化与赋值是两个完全不同的操作。初始化的含义是创建变量的同时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来代替

初始化的几种形式
```
  int i=0; //拷贝初始化
  int i={0}; //初始化列表
  int i{0}; //初始化列表
  int i(0); //直接初始化
```
> 一般来说，这几种初始化方法可以等价使用，但：
1 当初始值只有一个，拷贝初始化与直接初始化都行，但初始值有多个，一般只能用直接初始化
2 如果提供的是一个类内初始值，只能使用拷贝初始化或使用花括号
3 如果提供初始元素值的列表，只能在花括号

  * 列表初始化

    当用于内置类型的变量时，这种初始化形式有一个重要特点：如果使用初始化列表初始化且初始值存在丢失信息的风险，则编译器报错

  * 默认初始化：如果定义变量时没有指定初值，则变量被默认初始化
    * 内置类型：定义于任何函数体之外，初始化为0；函数体内部的内置类型变量不被初始化
    * 类的对象如果没有被显示初始化，其值由类决定

####  变量的声明（declaration）
  如果想声明一个变量而非定义它，就在前加extern
```
  extern int i; //声明i而非定义
  int j; //声明并定义j
```

> 变量能且只能被定义一次，但是可以被多次声明

如果在多个文件中使用同一个变量，必须将声明与定义分离。变量的定义必须出现在且只能出现在一个文件中，其他用到该变量的文件必须对其进行声明，但绝不能重复定义。

如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num。
正确的做法是：在任一个文件中定义外部变量num，而在另一文件中用extern对num作外部变量声明。即extern int num;
编译系统由此知道num是一个已在别处定义的外部变量，它先在本文件中找有无外部变量num，如果有，则将其作用域扩展到本行开始。

> par.h
```
#ifndef PAR
#define PAR

int ii=60;

#endif
```
> main.cc
```
#include <iostream>
#include "par.h"

extern int ii;  //将该句注释掉，程序也可以正常运行
int main()
{
    std::cout<<ii<<std::endl;
}
```

> par.h
```
#ifndef PAR
#define PAR

//int ii=60;
extern int ii;
#endif
```
> par.cc
```
#include "par.h"

//extern int ii;
int ii=60;
```
> main.cc
```
#include <iostream>
#include "par.h"

extern int ii;
int main()
{
    std::cout<<ii<<std::endl;
}
```


####  名字的作用域
名字都有作用域。而作用域scope是程序的一部分。以花括号分隔
  * 嵌套的作用域
    内层作用域与外层作用域
    * 局部变量会覆盖全局变量
    * 同时存在全局和局部变量时，已定义局部变量的作用域中可用`::reused`显式访问全局变量reused。
    * **但是用到全局变量时，尽量不适用重名的局部变量。**

### 2.3 复合类型

#### 引用

#### 指针

#### 理解复合类型的声明


### 2.4 const限定符

- 动机：希望定义一些不能被改变值的变量。

#### 1 初始化和const

- const对象**必须初始化**，且**不能被改变**。
- 默认情况下，const对象被设定为仅在文件内有效。多个文件出现了同名const，等于在不同文件中分别定义了独立变量。const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。

#### 2 const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
	- “对const的引用”简称为“常量引用”。只是个简称而已。严格来说，并不存在常量引用 
- 引用的类型必须与其所引用的对象的类型一致。**第一种例外情况就是** 初始化常量引用时允许用任意表达式作为初始值。code1。只要该表达式能转换成引用类型即可。
	- 理解当一个常量引用被绑定到另外一种类型上时到底发生了什么。code2
		- 编译器创建了临时量对象
		- 如果ri不是const，如果仍然执行以上操作结果如何？如果ri为非const，则允许对ri赋值，会改变ri所引用的对象的值。但此时ri绑定在临时量上，所以此种行为没有意义，c++将其视为非法，会报错！！！！
> code1
```code1
	int i=42; 
	const int &r1=i;
	const int &r2=42; 
	const int &r3=r1*2
	int &r4=r1*2;//错误，r4是非常量引用
```

> code2
```
double dv=3.14;
const int &ri=dv;

>>>>>>>>>>

const int temp=dv;
const int &ri=temp;
```

- 对const的引用可能引用一个非const对象：常量引用仅对引用可参与的操作做出了限定，对于引用本身是不是一个常量未作限定。
	- 理解：所谓指向常量的指针或引用，不过是指针和引用的“一厢情愿”，他们觉得自己指向了常量，所以自觉地不去改变所指向对象的值

```
    int i=42;
    int &r1=i;
    const int &r2=i;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //42 42 42

    r1=0;
    std::cout<<i<<","<<r1<<","<<r2<<std::endl; //0 0 0
```
> 下面的例子与临时量对象有关
```
    //需要强制类型转换的情况
    double j=42.66;
    const int &r3=j;
    //const int &r2=i;
    std::cout<<j<<","<<r3<<","<<std::endl; //42.66 42

    j=44.66;
    std::cout<<j<<","<<r3<<","<<std::endl; //44.66 42 
    
    
    //不需要强制类型转换的情况
    double i = 10.3;
    const double &i_ = i;
    std::cout<<i<<","<<i_<<","<<std::endl;  //10.3,10.3,   

    i = 12.3;
    std::cout<<i<<","<<i_<<","<<std::endl;  //12.3,12.3  
```

#### 3 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`。
	- 与引用类似，指针的类型必须与所指向对象类型一致，一种例外情况就是允许令一个指向常量的指针指向一个非常量对象
	- double dv=3.14; const double *cp=&dv;//正确，只是不能通过指针修改dv的值 
- **const pointer**：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 `int i = 0; int *const ptr = &i;`
	- 指针本身是个常量，并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。上面的*ptr=1;就可以重新赋值。

#### 4 顶层const

- `顶层const`：指针本身是个常量。更一般的，顶层const可以表示任意的对象是常量
- `底层const`：指针指向的对象是个常量。
	- 拷贝时严格要求相同的底层const资格。

```
int i=0;
int *const p1 =&i;   //顶层const
const int ci=42;	 //顶层const
const int *p2=&ci;	 //底层const
const int *const p3=p2; //靠左的const是底层 靠右的const是顶层
const int &r =ci;	 //底层const

//执行拷贝时，常量是顶层还是底层const区别明显，其中，顶层const无影响
//执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没有影响
i=ci;				//正确：拷贝ci，ci是顶层const，对此操作无影响
p2=p3;				//正确：p2 p3指向的对象类型相同，p3顶层const无影响

//执行拷贝时，拷入和拷出对象必须具有相同的底层const，或者两个对象的数据类型必须能转换
//一般来说，非常量可以转换成常量，反之不行
int *p=p3;			//错误：p3包含底层const定义，p没有
p2=p3;				//正确：p2 p3都是底层const
p2=&i;				//正确：int*能转换成const int*
int &r=ci;			//错误：普通int&不能绑定到int常量上
const int &r2=i;	//正确：const int& 可以绑定到普通int上
```

#### 5 `constexpr`和常量表达式（▲可选）

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是否是常量表达式由它的数据类型和初始值共同决定，如：
```
const int max_files = 20; //是常量表达式
int staff_size = 27;  //不是常量表达式
const int sz = get_size();  //不是常量表达式
```
- constexpr变量：`C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
```
constexpr int mf = 20;         //20是常量表达式
constexpr int limit = mf + 1;  //mf+1是常量表达式
constexpr int sz = size();     //只有当size是一个constexpr函数时，才是一条正确语句
```
如果认定变量是一个常量表达式，就把他声明成constexpr类型
- 字面值类型：算术类型、引用和指针都属于字面值类型
- 指针和constexpr

### 2.5 处理类型

#### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）
- 指针、常量和类型别名

```cpp
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring是char*的别名
const pstring cstr = 0; // 指向char的常量指针
// 如改写为const char *cstr = 0;不正确，为指向const char的指针

// 辅助理解（可代回后加括号）
// const pstring cstr = 0;代回后const (char *) cstr = 0;
// const char *cstr = 0;即为(const char *) cstr = 0;
```

#### auto类型说明符 c++11

- **auto**类型说明符：让编译器**自动推断类型**。auto定义的变量必须有初始值
- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，如果希望是顶层const需要自己加`const`

#### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- 如果对变量加括号，编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。
- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。
- `C++11`

### 2.6 自定义数据类型

#### 类内初始值

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型和变量所在位置决定。

如果是内置类型（int, short等）的变量为被显示初始化，它的值由定义的位置决定。定义与任何函数体之外的变量被初始化为0，定义在函数体内部的内置变量将不被初始化，其值时未定义的。

C++11新标准规定可以为数据成员提供一个**类内初始值（in-class initializer）**。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。

1、类内初始值和赋值类似，或者放在**花括号里（如数组）**，或者放在**等号右边**，不能使用圆括号。

2、如果在构造方法里面对赋予了类内初始值的变量再次赋值，类内初始值将被覆盖。

```
class Student {
public:
	Student() = default;
	Student(int _age):age(_age) {};
	string name;
	int age = 10;
	int _class {3};
	int grade;
 
	void printInfo() { cout << "age:" << age << ", grade:" << grade << ", class:" << _class << endl; }
};
 
int main() {
	Student student1;
	student1.printInfo();
 
	Student student2(12);
	student2.printInfo();
	return 0;
}
```

上述代码输出：

```
age:10, grade:37, class:3
age:12, grade:24, class:3
```



1）成员变量grade没有被初始化，其值时未定义的，可能为任何值

2）student1对象的age和_class对象均由类内初始值初始化

3）student2对象的age变量的类内初始值被构造方法传递的参数值覆盖



## 3 运算符/表达式

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |


### 表达式基础
- c++定义了一元运算符（unary operator）和二元运算符（binary operator）
- **运算对象转换**：小整数类型会被提升为较大的整数类型
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
    - C中原意：左值**可以**在表达式左边，右值不能。
    - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
    - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
- **优先级与结合律**
- **求值顺序**：`int i = f1() + f2()`
  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义
  - 有4中运算符明确规定了运算对象的求值顺序
  	- && ：它规定了先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧
  	- ||
  	- (?:)
  	- , 


### 3.1 算术运算符

算术运算符的运算对象和求值结果都是**右值**
**作用**：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
//加减乘除
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除结果依然是整数，小数部分舍去
	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl;  //0
	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; //报错，除数不可以为0
	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout << d1 / d2 << endl;  //2。运算的结果也可以是小数
	system("pause");
	return 0;
}
```

> 总结：在除法运算中，除数不能为0




**示例2：**

```C++
//取模
int main() {
	int a1 = 10;
	int b1 = 3;
	cout << 10 % 3 << endl;    //1
	int a2 = 10;
	int b2 = 20;
	cout << a2 % b2 << endl;   //10
	int a3 = 10;
	int b3 = 0;
	//cout << a3 % b3 << endl; //取模运算时，除数也不能为0
	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;
	//cout << d1 % d2 << endl;
	system("pause");
	return 0;
}
```

> 总结：只有整型变量可以进行取模运算


**示例3：**

```C++
//递增
int main() {
	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11
	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11
	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << a2 << endl;  //11
	cout << b2 << endl;  //110
	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << a3 << endl;  //11
	cout << b3 << endl;	 //100
	system("pause");
	return 0;
}
```



> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反








### 3.2 赋值运算符

- 赋值运算的**返回结果时它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，使用其当条件时应该加括号。
- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响）
  任意复合运算符op等价于`a = a op b;`
  **作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |



**示例：**

```C++
int main() {
	//赋值运算符
	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;
	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl; //12
	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;  //8
	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;
	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;
	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;
	system("pause");
	return 0;
}
```









### 3.3 比较运算符

运算对象和求值结果都是右值
**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {
	int a = 10;
	int b = 20;
	cout << (a == b) << endl; // 0 
	cout << (a != b) << endl; // 1
	cout << (a > b) << endl; // 0
	cout << (a < b) << endl; // 1
	cout << (a >= b) << endl; // 0
	cout << (a <= b) << endl; // 1
	
	system("pause");
	return 0;
}
```



> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 












### 3.4 逻辑运算符

运算对象和求值结果都是右值
**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |


- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {
	int a = 10;
	cout << !a << endl; // 0
	cout << !!a << endl; // 1
	system("pause");
	return 0;
}
```

> 总结： 真变假，假变真




**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {
	int a = 10;
	int b = 10;
	cout << (a && b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a && b) << endl;// 0 
	a = 0;
	b = 0;
	cout << (a && b) << endl;// 0
	system("pause");
	return 0;
}
```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==






**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {
	int a = 10;
	int b = 10;
	cout << (a || b) << endl;// 1
	a = 10;
	b = 0;
	cout << (a || b) << endl;// 1 
	a = 0;
	b = 0;
	cout << (a || b) << endl;// 0
	system("pause");
	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==


### 递增递减运算符

必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置对象则将对象原始值的副本作为右值返回。

* 前置版本`j = ++i`，先加一后赋值
* 后置版本`j = i++`，先赋值后加一
* 后置递增运算符优先级高于解引用运算符 *ptr++ 等价于 *(prt++)


**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

`*iter++`等价于`*(iter++)`，递增优先级较高

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性


### 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号


### 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

### 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

应用：

```c++
unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
1UL << 12;  // 代表第12个学生通过
quiz1 |= (1UL << 12);   // 将第12个学生置为已通过
quiz1 &= ~(1UL << 12);  // 将第12个学生修改为未通过
bool stu12 = quiz1 & (1UL << 12);   // 判断第12个学生是否通过
```

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。


### 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。


### 类型转换

#### 1 隐式类型转换

> 设计为尽可能避免损失精度，即转换为更精细类型。

下面情况中，编译器会自动地转换运算对象的类型：

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有转换。

##### 1.1 算术转换
算术转换的含义是把一种算术类型转换成另外一种算术类型。前文数据类型中已经提到
- 整型提升

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

##### 1.2 其他转换

> p143

- 数组转换成指针
- 指针的转换


#### 2 显式类型转换（尽量避免）

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

- **dynamic_cast**：支持运行时类型识别。

- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

##### 旧式强制类型转换
```
type (expr) //函数形式的强制类型转换
(type) expr //c语言风格
```


## 4 程序流程结构（语句）

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码



### 4.1 选择结构（条件语句）

#### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句

- **悬垂else**（dangling else）：用来描述在嵌套的`if else`语句中，如果`if`比`else`多时如何处理的问题。C++使用的方法是`else`匹配最近没有配对的`if`。--使用花括号

1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![img](assets/clip_image002.png)

   示例：

   ```C++
   int main() {
   	//选择结构-单行if语句
   	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   	int score = 0;
   	cout << "请输入一个分数：" << endl;
   	cin >> score;
   	cout << "您输入的分数为： " << score << endl;
   	//if语句
   	//注意事项，在if判断语句后面，不要加分号
   	if (score > 600)  //此处如果加分号，大括号内一定会运行
   	{
   		cout << "我考上了一本大学！！！" << endl;
   	}
   	system("pause");
   	return 0;
   }
   ```

   


> 注意：if条件表达式后不要加分号






2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

![img](assets/clip_image002-1541662519170.png)



示例：

```C++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else
	{
		cout << "我未考上一本大学" << endl;
	}
	system("pause");
	return 0;
}
```











3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

![img](assets/clip_image002-1541662566808.png)







示例：

```C++
	int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```









**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断



案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。



**示例：**

```c++
int main() {
	int score = 0;
	cout << "请输入考试分数：" << endl;
	cin >> score;
	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
		if (score > 700)
		{
			cout << "我考上了北大" << endl;
		}
		else if (score > 650)
		{
			cout << "我考上了清华" << endl;
		}
		else
		{
			cout << "我考上了人大" << endl;
		}
		
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}
	system("pause");
	return 0;
}
```







**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](assets/三只小猪.jpg)









#### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {
	int a = 10;
	int b = 20;
	int c = 0;
	c = (a > b ? a : b);
	cout << "c = " << c << endl;
	//C++中三目运算符返回的是变量,可以继续赋值
	(a > b ? a : b) = 100;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	system("pause");
	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰








#### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch(表达式)   //表达式只能为整型或字符型，不可以是区间
{
	case 结果1：执行语句;break;  //若不加break，会继续执行后面的
	case 结果2：执行语句;break;  //执行语句若为多行，必须加{}
	...
	default:执行语句;break;
}
```
- 如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或是遇到一条break为止





**示例：**

```C++
int main() {
	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片
	int score = 0;
	cout << "请给电影打分" << endl;
	cin >> score;
	switch (score)
	{
	case 10:
	case 9:
		cout << "经典" << endl;
		break;   //退出当前分支
	case 8:
		cout << "非常好" << endl;
		break;
	case 7:
	case 6:
		cout << "一般" << endl;
		break;
	default:
		cout << "烂片" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



> 注意1：switch语句中表达式类型只能是整型或者字符型
> 注意2：case里如果没有break，那么程序会一直向下执行
> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间






### 4.2 循环结构

#### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![img](assets/clip_image002-1541668640382.png)







**示例：**

```C++
int main() {
	int num = 0;
	while (num < 10)
	{
		cout << "num = " << num << endl;
		num++;
	}
	
	system("pause");
	return 0;
}
```



> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环








**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。



![猜数字](assets/猜数字.jpg)

















#### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![img](assets/clip_image002-1541671163478.png)



**示例：**

```C++
int main() {
	int num = 0;
	do
	{
		cout << num << endl;
		num++;
	} while (num < 10);
	
	
	system("pause");
	return 0;
}
```



> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件












**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数

将一个多位数每个位置取出： num%10---个位    num/10 %10 （反复做即可）---十位



















#### 4.2.3 for循环语句

**作用：** 满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`
//起始条件可没有
- **范围for**： `for (declaration: expression) statement`

**示例：**

```C++
int main() {
	for (int i = 0; i < 10; i++)
	{
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```







**详解：**

![1541673704101](assets/1541673704101.png)



> 注意：for循环中的表达式，要用分号进行分隔
> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用










**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![timg](assets/timg.gif)













#### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![1541676003486](assets/1541676003486.png)











**示例：**

```C++
int main() {
	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			cout << "*" << " ";
		}
		cout << endl;
	}
	system("pause");
	return 0;
}
```













**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![0006018857256120_b](assets/0006018857256120_b.jpg)





### 4.3 跳转语句

#### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句



**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;
	int num = 0;
	cin >> num;
	switch (num)
	{
	case 1:
		cout << "您选择的是普通难度" << endl;
		break;
	case 2:
		cout << "您选择的是中等难度" << endl;
		break;
	case 3:
		cout << "您选择的是困难难度" << endl;
		break;
	}
	system("pause");
	return 0;
}
```



**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout << i << endl;
	}
	system("pause");
	return 0;
}
```



**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	system("pause");
	return 0;
}
```















#### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

**示例：**

```C++
int main() {
	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;  //进行筛选
		}
		cout << i << endl;
	}
	
	system("pause");
	return 0;
}
```



> 注意：continue并没有使整个循环终止，而break会跳出循环










#### 4.3.3 goto语句

**作用：**可以无条件跳转语句



**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置



**示例：**

```C++
int main() {
	cout << "1" << endl;
	goto FLAG;
	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;
	FLAG:
	cout << "5" << endl;
	
	system("pause");
	return 0;
}
```



> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱



### try语句块和异常处理

- **throw表达式**：异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常。
- **try语句块**：以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为**异常处理代码**。
- **异常类**：用于在 `throw`表达式和相关的 `catch`子句之间传递异常的具体信息。






## 5 数组

### 5.1 概述

所谓数组，就是一个集合，里面存放了相同类型的数据元素



**特点1：**数组中的每个==数据元素都是相同的数据类型==

**特点2：**数组是由==连续的内存==位置组成的


- 访问数组元素
> 数组下标的类型：`size_t` 。
> 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
> 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。


- 数组和指针

> 使用数组时，编译器一般会把它转换成指针。
> 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 
> **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。







![1541748375356](assets/1541748375356.png)













### 5.2 一维数组

#### 5.2.1 一维数组定义方式

一维数组定义的三种方式：

1. ` 数据类型  数组名[ 数组长度 ]; `
2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`
3. `数据类型  数组名[ ] = { 值1，值2 ...};`

- int *arr[sz] //含有sz个整型指针的数组

示例

```C++
int main() {
	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];
	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;
	//利用下标输出
	cout << score[0] << endl;
	cout << score[1] << endl;
	cout << score[2] << endl;
	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	
	//逐个输出
	//cout << score2[0] << endl;
	//cout << score2[1] << endl;
	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i < 10; i++)
	{
		cout << score2[i] << endl;
	}
	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };
	for (int i = 0; i < 10; i++)
	{
		cout << score3[i] << endl;
	}
	system("pause");
	return 0;
}
```



> 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名
> 总结2：数组中下标是从0开始索引








#### 5.2.2 一维数组数组名

一维数组名称的**用途**：

1. 可以统计整个数组在内存中的长度
2. 可以获取数组在内存中的首地址





**示例：**

```C++
int main() {
	//数组名用途
	//1、可以获取整个数组占用内存空间大小
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;
	cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;
	cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;
	//2、可以通过数组名获取到数组首地址
	cout << "数组首地址为： " << (int)arr << endl;
	cout << "数组中第一个元素地址为： " << (int)&arr[0] << endl;
	cout << "数组中第二个元素地址为： " << (int)&arr[1] << endl;
	//arr = 100; 错误，数组名是常量，因此不可以赋值
	system("pause");
	return 0;
}
```



> 注意：数组名是常量，不可以赋值
> 总结1：直接打印数组名，可以查看数组所占内存的首地址
>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小










**练习案例1**：五只小猪称体重

**案例描述：**

在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};

找出并打印最重的小猪体重。









**练习案例2：**数组元素逆置

**案例描述：**请声明一个5个元素的数组，并且将元素逆置.

(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);

















#### 5.2.3 冒泡排序

**作用：** 最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
3. 重复以上的步骤，每次比较次数-1，直到不需要比较

![1541905327273](assets/1541905327273.png)

**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

```C++
int main() {
	int arr[9] = { 4,2,8,0,5,7,1,3,9 };
	for (int i = 0; i < 9 - 1; i++)
	{
		for (int j = 0; j < 9 - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << endl;
	}
    
	system("pause");
	return 0;
}
```









### 5.3 二维数组

二维数组就是在一维数组上，多加一个维度。

![1541905559138](assets/1541905559138.png)

#### 5.3.1 二维数组定义方式

二维数组定义的四种方式：

1. ` 数据类型  数组名[ 行数 ][ 列数 ]; `
2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`
4. ` 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`



> 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==
示例：

```C++
int main() {
	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			cout << arr[i][j] << " ";
		}
		cout << endl;
	}
	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};
	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 
	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
	
	system("pause");
	return 0;
}
```



> 总结：在定义二维数组时，如果初始化了数据，可以省略行数












#### 5.3.2 二维数组数组名



* 查看二维数组所占内存空间
* 获取二维数组首地址





**示例：**

```C++
int main() {
	//二维数组数组名
	int arr[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};
	cout << "二维数组大小： " << sizeof(arr) << endl;
	cout << "二维数组一行大小： " << sizeof(arr[0]) << endl;
	cout << "二维数组元素大小： " << sizeof(arr[0][0]) << endl;
	cout << "二维数组行数： " << sizeof(arr) / sizeof(arr[0]) << endl;
	cout << "二维数组列数： " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;
	//地址
	cout << "二维数组首地址：" << arr << endl;
	cout << "二维数组第一行地址：" << arr[0] << endl;
	cout << "二维数组第二行地址：" << arr[1] << endl;
	cout << "二维数组第一个元素地址：" << &arr[0][0] << endl;
	cout << "二维数组第二个元素地址：" << &arr[0][1] << endl;
	system("pause");
	return 0;
}
```



> 总结1：二维数组名就是这个数组的首地址
> 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小












#### **5.3.3 二维数组应用案例**

**考试成绩统计：**

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**

|      | 语文 | 数学 | 英语 |
| ---- | ---- | ---- | ---- |
| 张三 | 100  | 100  | 100  |
| 李四 | 90   | 50   | 100  |
| 王五 | 60   | 70   | 80   |





**参考答案：**

```C++
int main() {
	int scores[3][3] =
	{
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};
	string names[3] = { "张三","李四","王五" };
	for (int i = 0; i < 3; i++)
	{
		int sum = 0;
		for (int j = 0; j < 3; j++)
		{
			sum += scores[i][j];
		}
		cout << names[i] << "同学总成绩为： " << sum << endl;
	}
	system("pause");
	return 0;
}
```













## 6 函数

### 6.1 概述

**作用：**将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型 

2、函数名

3、参数表列

4、函数体语句 

5、return 表达式

**语法：** 

```C++
返回值类型 函数名 （参数列表）
{
       函数体语句
       return表达式
}
```



* 返回值类型 ：一个函数可以返回一个值。在函数定义中
* 函数名：给函数起个名称
* 参数列表：使用该函数时，传入的数据
* 函数体语句：花括号内的代码，函数内需要执行的语句
* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据





**示例：**定义一个加法函数，实现两个数相加

```C++
//函数定义
int add(int num1, int num2)
{
	int sum = num1 + num2;
	return sum;
}
```











### 6.3 函数的调用

**功能：**使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
{
	int sum = num1 + num2;
	return sum;
}
int main() {
	int a = 10;
	int b = 10;
	//调用add函数
	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
	cout << "sum = " << sum << endl;
	a = 100;
	b = 100;
	sum = add(a, b);
	cout << "sum = " << sum << endl;
	system("pause");
	return 0;
}
```

> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参








### 6.4 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生，并不会影响实参==



**示例：**

```C++
void swap(int num1, int num2)
{
	cout << "交换前：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;
	int temp = num1;
	num1 = num2;
	num2 = temp;
	cout << "交换后：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;
	//return ; 当函数声明时候，不需要返回值，可以不写return
}
int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout << "mian中的 a = " << a << endl;
	cout << "mian中的 b = " << b << endl;
	system("pause");
	return 0;
}
```



> 总结： 值传递时，形参是修饰不了实参的








### **6.5 函数的常见样式**

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

**示例：**

```C++
//函数常见样式
//1、 无参无返
void test01()
{
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout << "this is test01" << endl;
	//test01(); 函数调用
}
//2、 有参无返
void test02(int a)
{
	cout << "this is test02" << endl;
	cout << "a = " << a << endl;
}
//3、无参有返
int test03()
{
	cout << "this is test03 " << endl;
	return 10;
}
//4、有参有返
int test04(int a, int b)
{
	cout << "this is test04 " << endl;
	int sum = a + b;
	return sum;
}
```











### 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。



*  函数的**声明可以多次**，但是函数的**定义只能有一次**



**示例：**

```C++
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)
{
	return a > b ? a : b;
}
int main() {
	int a = 100;
	int b = 200;
	cout << max(a, b) << endl;
	system("pause");
	return 0;
}
```











### 6.7 函数的分文件编写

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

```C++
//swap.h文件
#include<iostream>
using namespace std;
//实现两个数字交换的函数声明
void swap(int a, int b);
```

```C++
//swap.cpp文件
#include "swap.h"
void swap(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
}
```

```C++
//main函数文件
#include "swap.h"
int main() {
	int a = 100;
	int b = 200;
	swap(a, b);
	system("pause");
	return 0;
}
```



### ***************************




### 6.1 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。

```C++
返回值类型 函数名 （参数列表）
{
       函数体语句
       return表达式
}
```

- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
  - 执行函数的第一步是（隐式）定义并初始化它的形参
- **形参和实参**：实参是形参的初始值。形参和实参的**个数**和**类型**必须匹配上。
- 函数的形参列表：``void f(void) {}``   //显式定义空形参列表
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型**不能是数组类型或者函数类型**，**但可以是指向数组或者函数的指针**。



#### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。（名字有作用域）
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的。同时局部变量会**隐藏**（hide）在外层作用域中的同名的其他所有声明。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。直到程序终止被销毁

#### 函数声明

- **函数声明**：函数的名字也必须在使用前声明。函数的声明和定义唯一的区别是声明无需函数体，也无须形参的名字，用一个分号替代。
	- 函数声明主要用于描述函数的三要素（返回类型、函数名、形参类型）即定义了函数的接口，也称**函数原型**。
	- 函数的声明不包含函数体，所以无须形参的的名字
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

### 6.2 参数传递

- 每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化
- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

#### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。

#### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**返回额外的信息**。
- 经常用引用形参来避免不必要的复制。
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为**常量引用**。

#### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。
	- 把函数不会改变的形参定义成（普通）引用是一种比较常见的错误
	- 以上做法带给调用者一种误导，即函数可以修改它的实参的值
	- 此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。
	- 例如，我们不能讲const对象、字面值或者需要类型转换的对象传递给普通的引用形参

#### 数组形参

- 数组有两个性质：不允许拷贝数组、使用数组时通常会将其转换成指针。
- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针；无法以值传递的方式使用数组参数。
- 管理数组形参有三种方法：
	- 1 使用标记指定数组长度：数组本身包含结束标记；
	- 2 使用标准库规范：传递指向数组首尾元素的指针；
	- 3 显示传递一个表示数组大小的形参：专门定义表示数组大小的形参。
- 允许将变量定义成数组的引用
	- f(int &arr [10])   //错误，将arr声明成了引用的数组
	- f(int (&arr) [10])  //正确，arr是具有10个整数的整型数组的引用
- 要注意数组的实际长度，不能越界。

#### main处理命令行选项

- `int main(int argc, char *argv[]){...}`
- `int main(int argc, char **argv){...}`
- 第一个形参，表示数组中字符串的数量，代表参数的个数；第二个形参是参数C风格字符串数组。

#### 可变形参

为了编写能处理不同数量实参的函数，C++11提供了两种主要方法：initializer_list 与 可变参数模板 ，还有省略符

1. `initializer_list`提供的操作（`C++11`）：

实参数量未知但全部实参的类型相同。

| 操作 | 解释 |
|-----|-----|
| `initializer_list<T> lst;` | 默认初始化；`T`类型元素的空列表 |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)` | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst` | 同上 |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中微元素下一位置的指针 |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
2. 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。

### 6.3返回类型和return语句

return语句有两种形式

```
return;

return expression;

```

#### 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

#### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
- 返回类类型的函数和调用运算符
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。可以像使用其他左值那样来使用**返回引用的函数的调用**，即能为返回类型是非常量引用的函数的结果赋值。
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。

#### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。可以返回数组的指针或引用

```
typedef int arrT[10]; //arrT是类型别名，它表示的类型是含有10个int的数组

using arrT=int [10];  //arrT的等价声明

arrT* func(int i);    //func 返回一个指向含有10个int的数组的指针
```



```
int arr[10]; 
int *p1[10]; //p1是含有10个指针的数组
int (*p2)[10] =&arr;  //p2是一个指针，指向含有10个int的数组
```



- 声明一个返回数组指针的函数
	- 返回数组指针的函数形式：`Type (*function (parameter_list))[dimension]`
	- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10]；`，然后 `arrT* func() {...}`
	- 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

### 6.4 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
- `main`函数不能重载。
- **重载和const形参**：
  - 一个有顶层const的形参和另一个没有顶层const的形参，函数无法区分。
  	-  `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
  	-  `Record lookup(const Phone)`和 `Record lookup(Phone)`无法区分。
  - 相反，是否有某个底层const形参可以区分。 
  	- `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分。
  	- `Record lookup(Account&)`和 `Record lookup(const Account&)`可以区分。
- const_cast
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。

### 6.5 特殊用途语言特性

#### 默认实参

- `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

#### 内联（inline）函数

- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。

#### constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型。
- `constexpr`函数应该在头文件中定义。

#### 调试帮助

- `assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

### 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

### 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。






## 7 指针

### 7.1 指针的基本概念

**指针的作用：** 可以通过指针间接访问内存

是一种 `"指向（point to）"`另外一种类型的复合类型。

* 内存编号是从0开始记录的，一般用十六进制数字表示
* 可以利用指针变量保存地址

  

### 7.2 指针变量的定义和使用

指针变量定义语法： `数据类型 * 变量名；`

- **定义**指针类型： `int *ip1;`，**从右向左读有助于阅读**，`ip1`是指向`int`类型的指针。
- **指针的类型与所指向的对象类型必须严格匹配（均为同一类型int、double等）**，除了两种特殊情况，一种为：允许令一个指向常量的指针指向一个非常量对象
- 建议：初始化所有指针。
- 理解复合类型的声明
	- 从右向左阅读复合类型的定义 
	- `int* p1, p2;//*是对p1的修饰，所以p2还是int型`
	- 指向指针的指针。
		- int ival=1024;
		- int *pi=&ival; //pi指向一个int型的数
		- int **pi=&pi;  //ppi指向一个int型的指针
	- 指向指针的引用。引用本身不是对象，所以不能定义指向引用的指针
		- int i=42;   //
		- int *p;	  //p为int型指针
		- int *&r=p;  //r是对指针p的引用。从右向左阅读复合类型的定义。离变量名最近的符号&对变量类型有直接影响，因此r为引用。声明符的其余部分用以确定r引用的类型是什么 
		- r=&i;       //r引用了一个指针，因此给r赋值&i就是令p指向i
		- *r=0;		  //

**示例：**

```C++
int main() {
	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;
	//指针变量赋值
	p = &a; //指针指向变量a的地址
	cout << &a << endl; //打印数据a的地址
	cout << p << endl;  //打印指针变量p
	//2、指针的使用
	//通过*操作指针变量指向的内存
	cout << "*p = " << *p << endl;
	system("pause");
	return 0;
}
```



指针变量和普通变量的区别

* 普通变量存放的是数据,指针变量存放的是地址
* 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用



> 总结1： 我们可以通过 & 符号 获取变量的地址
> 总结2：利用指针可以记录地址
> 总结3：对指针变量解引用，可以操作指针指向的内存










### 7.3 指针所占内存空间



提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？



**示例：**

```C++
int main() {
	int a = 10;
	int * p;
	p = &a; //指针指向数据a的地址
	cout << *p << endl; //* 解引用
	cout << sizeof(p) << endl;
	cout << sizeof(char *) << endl;
	cout << sizeof(float *) << endl;
	cout << sizeof(double *) << endl;
	system("pause");
	return 0;
}
```



> 总结：所有指针类型在32位操作系统下是4个字节










### 7.4 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的



**示例1：空指针**

```C++
int main() {
	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;
	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout << *p << endl;
	system("pause");
	return 0;
}
```















**野指针**：指针变量指向非法的内存空间

**示例2：野指针**

```C++
int main() {
	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;
	//访问野指针报错 
	cout << *p << endl;
	system("pause");
	return 0;
}
```





> 总结：空指针和野指针都不是我们申请的空间，因此不要访问。








### 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量




**示例：**


```c++
int main() {
	int a = 10;
	int b = 10;
	//const修饰的是常量，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	
	//const修饰的是指针，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确
    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误
	system("pause");
	return 0;
}
```



> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量








### 7.6 指针和数组

**作用：**利用指针访问数组中元素

**示例：**

```C++
int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int * p = arr;  //指向数组的指针
	cout << "第一个元素： " << arr[0] << endl;
	cout << "指针访问第一个元素： " << *p << endl;
	for (int i = 0; i < 10; i++)
	{
		//利用指针遍历数组
		cout << *p << endl;
		p++;
	}
	system("pause");
	return 0;
}
```











### 7.7 指针和函数

**作用：**利用指针作函数参数，可以修改实参的值



**示例：**

```C++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
int main() {
	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参
	swap2(&a, &b); //地址传递会改变实参
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	system("pause");
	return 0;
}
```



> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递












### 7.8 指针、数组、函数

**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序

例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };



**示例：**

```c++
//冒泡排序函数
void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组函数
void printArray(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << endl;
	}
}
int main() {
	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);
	bubbleSort(arr, len);
	printArray(arr, len);
	system("pause");
	return 0;
}
```



> 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针








## 8 结构体

### 8.1 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型



### 8.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
* 定义结构体时顺便创建变量

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 
int main() {
	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略
	stu1.name = "张三";
	stu1.age = 18;
	stu1.score = 100;
	
	cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;
	//结构体变量创建方式2
	struct student stu2 = { "李四",19,60 };
	cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;
	stu3.name = "王五";
	stu3.age = 18;
	stu3.score = 80;
	
	cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;
	system("pause");
	return 0;
}
```



> 总结1：定义结构体时的关键字是struct，不可省略
> 总结2：创建结构体变量时，关键字struct可以省略
> 总结3：结构体变量利用操作符 ''.''  访问成员








### 8.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**` struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}
int main() {
	
	//结构体数组
	struct student arr[3]=
	{
		{"张三",18,80 },
		{"李四",19,60 },
		{"王五",20,70 }
	};
	for (int i = 0; i < 3; i++)
	{
		cout << "姓名：" << arr[i].name << " 年龄：" << arr[i].age << " 分数：" << arr[i].score << endl;
	}
	system("pause");
	return 0;
}
```











### 8.4 结构体指针

**作用：**通过指针访问结构体中的成员



* 利用操作符 `-> `可以通过结构体指针访问结构体属性



**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};
int main() {
	
	struct student stu = { "张三",18,100, };
	
	struct student * p = &stu;
	
	p->score = 80; //指针通过 -> 操作符可以访问成员
	cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;
	
	system("pause");
	return 0;
}
```



> 总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员












### 8.5 结构体嵌套结构体

**作用：** 结构体中的成员可以是另一个结构体

**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};
//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};
int main() {
	struct teacher t1;
	t1.id = 10000;
	t1.name = "老王";
	t1.age = 40;
	t1.stu.name = "张三";
	t1.stu.age = 18;
	t1.stu.score = 100;
	cout << "教师 职工编号： " << t1.id << " 姓名： " << t1.name << " 年龄： " << t1.age << endl;
	
	cout << "辅导学员 姓名： " << t1.stu.name << " 年龄：" << t1.stu.age << " 考试分数： " << t1.stu.score << endl;
	system("pause");
	return 0;
}
```



**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题









### 8.6 结构体做函数参数 

**作用：**将结构体作为参数向函数中传递

传递方式有两种：

* 值传递
* 地址传递

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};
//值传递
void printStudent(student stu )
{
	stu.age = 28;
	cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
}
//地址传递
void printStudent2(student *stu)
{
	stu->age = 28;
	cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;
}
int main() {
	student stu = { "张三",18,100};
	//值传递
	printStudent(stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;
	cout << endl;
	//地址传递
	printStudent2(&stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
	system("pause");
	return 0;
}
```

> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递






### 8.7 结构体中 const使用场景

**作用：**用const来防止误操作

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};
//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu->age = 100; //操作失败，因为加了const修饰
	cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;
}
int main() {
	student stu = { "张三",18,100 };
	printStudent(&stu);
	system("pause");
	return 0;
}
```









### 8.8 结构体案例

#### 8.8.1 案例1

**案例描述：**

学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下

设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员

学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值

最终打印出老师数据以及老师所带的学生数据。



**示例：**

```C++
struct Student
{
	string name;
	int score;
};
struct Teacher
{
	string name;
	Student sArray[5];
};
void allocateSpace(Teacher tArray[] , int len)
{
	string tName = "教师";
	string sName = "学生";
	string nameSeed = "ABCDE";
	for (int i = 0; i < len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j < 5; j++)
		{
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}
void printTeachers(Teacher tArray[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << tArray[i].name << endl;
		for (int j = 0; j < 5; j++)
		{
			cout << "\t姓名：" << tArray[i].sArray[j].name << " 分数：" << tArray[i].sArray[j].score << endl;
		}
	}
}
int main() {
	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>
	Teacher tArray[3]; //老师数组
	int len = sizeof(tArray) / sizeof(Teacher);
	allocateSpace(tArray, len); //创建数据
	printTeachers(tArray, len); //打印数据
	
	system("pause");
	return 0;
}
```









#### 8.8.2 案例2

**案例描述：**

设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。

通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。



五名英雄信息如下：

```C++
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
```









**示例：**

```C++
//英雄结构体
struct hero
{
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(hero arr[] , int len)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j].age > arr[j + 1].age)
			{
				hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << "姓名： " << arr[i].name << " 性别： " << arr[i].sex << " 年龄： " << arr[i].age << endl;
	}
}
int main() {
	struct hero arr[5] =
	{
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
	};
	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数
	bubbleSort(arr, len); //排序
	printHeros(arr, len); //打印
	system("pause");
	return 0;
}
```



# 







